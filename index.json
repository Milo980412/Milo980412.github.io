[{"categories":["前端"],"content":"React从入门到精通","date":"2022-06-15","objectID":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/","tags":["前端","React"],"title":"React从入门到精通","uri":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":" 引用 B站视频 尚硅谷React技术全家桶全套完整版（零基础入门到精通/男神天禹） 引用 笔记链接 React技术全家桶 部分笔记内容如下： 01_基础知识以及 jsx 语法 📢 大家好 ，我是Milo同学，最近在学习 React，是我学习的第一个框架 先附上React官网 ，有很多问题都要通过查询官方文档来解决，要学会查文档~ ","date":"2022-06-15","objectID":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:0:0","tags":["前端","React"],"title":"React从入门到精通","uri":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"一、React 简介 ","date":"2022-06-15","objectID":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:1:0","tags":["前端","React"],"title":"React从入门到精通","uri":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"1. 关于 React 整几个面试题来认识一下~~ 什么是 React ？ React 是一个用于构建用户界面的 JavaScript 库。 是一个将数据渲染为 HTML 视图的开源 JS 库 它遵循基于组件的方法，有助于构建可重用的 UI 组件 它用于开发复杂的交互式的 web 和移动 UI React 有什么特点？ 声明式编码，组件化编码 使用虚拟 DOM 而不是真正的 DOM 它可以用服务器渲染 它遵循单向数据流或数据绑定 高效（优秀的Diffing算法、使用虚拟 DOM 而不是真正的 DOM） React 的一些主要优点？ 它提高了应用的性能（优秀的Diffing算法、使用虚拟 DOM 而不是真正的 DOM） 可以方便在客户端和服务器端使用 由于使用 JSX，代码的可读性更好 使用React，编写 UI 测试用例变得非常容易 ","date":"2022-06-15","objectID":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:1:1","tags":["前端","React"],"title":"React从入门到精通","uri":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"2. Hello React 首先需要引入几个 react 包，我直接用的是老师下载好的，核心库必须在扩展库前面引入！ React 核心库、操作 DOM 的 react 扩展库、将 jsx 转为 js 的 babel 库 \u003c!-- 准备好一个“容器” --\u003e \u003cdiv id=\"test\"\u003e\u003c/div\u003e \u003c!-- 引入react核心库 --\u003e \u003cscript type=\"text/javascript\" src=\"../js/react.development.js\"\u003e\u003c/script\u003e \u003c!-- 引入react-dom，用于支持react操作DOM --\u003e \u003cscript type=\"text/javascript\" src=\"../js/react-dom.development.js\"\u003e\u003c/script\u003e \u003c!-- 引入babel，用于将jsx转为js --\u003e \u003cscript type=\"text/javascript\" src=\"../js/babel.min.js\"\u003e\u003c/script\u003e /* 此处一定要写babel */ \u003cscript type=\"text/babel\" \u003e\u003c/script\u003e 然后在里创建虚拟DOM //1.创建虚拟DOM const VDOM = \u003ch1\u003eHello,React\u003c/h1\u003e //2.渲染虚拟DOM到页面 ReactDOM.render(VDOM,document.querySelector(\".test\")) 如果我创建两个虚拟DOM，渲染两次（注意⚠️） // 1.创建虚拟DOM const VDOM = \u003ch1\u003eHello,React\u003c/h1\u003e const VDOM2 = \u003ch1\u003eHello,Milo\u003c/h1\u003e // 2.渲染虚拟DOM到页面 ReactDOM.render(VDOM,document.getElementById('test')) ReactDOM.render(VDOM2,document.getElementById('test')) 由于渲染不是一个叠加操作，而是覆盖操作，页面只会渲染生成hello，milo的DOM操作！ ","date":"2022-06-15","objectID":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:1:2","tags":["前端","React"],"title":"React从入门到精通","uri":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"3. 虚拟 DOM 和真实 DOM 的两种创建方法 为什么不用js而使用jsx？ JS创建虚拟DOM太繁琐了，JSX更方便 3.1 JS 创建虚拟 DOM //1.创建虚拟DOM,创建嵌套格式的dom const VDOM=React.createElement('h1',{id:'title'},React.createElement('span',{},'hello,React')) //2.渲染虚拟DOM到页面 ReactDOM.render(VDOM,document.getElementById('test')) 3.2 Jsx 创建虚拟DOM //1.创建虚拟DOM const VDOM = ( /* 此处一定不要写引号，因为不是字符串 */ \u003ch1 id=\"title\"\u003e \u003cspan\u003eHello,React\u003c/span\u003e \u003c/h1\u003e ) //2.渲染虚拟DOM到页面 ReactDOM.render(VDOM,document.getElementById('test')) js 的写法并不是常用的，常用jsx来写，毕竟JSX更符合书写的习惯 3.3 虚拟DOM与真实DOM 关于虚拟DOM： 本质是Object类型的对象（一般对象） 虚拟DOM比较“轻”，真实DOM比较“重”，因为虚拟DOM是React内部在用，无需真实DOM上那么多的属性。 虚拟DOM最终会被React转化为真实DOM，呈现在页面上。 console.log('虚拟DOM',VDOM); //[Object Object] console.log(typeof VDOM); //object console.log(VDOM instanceof Object); //true const TDOM = document.getElementById('demo') console.log('虚拟DOM',VDOM); //[Object Object] console.log('真实DOM',TDOM); //\u003cdiv id=\"demo\"\u003e\u003c/div\u003e debugger; ","date":"2022-06-15","objectID":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:1:3","tags":["前端","React"],"title":"React从入门到精通","uri":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"二、jsx 语法 ","date":"2022-06-15","objectID":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:2:0","tags":["前端","React"],"title":"React从入门到精通","uri":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"1. jsx语法规则 定义虚拟DOM，不能使用“” 标签中混入JS表达式的时候使用{}，toLowerCase()方法可转化成小写 // 1.创建虚拟DOM const VDOM = ( \u003ch2 id={myId.toLowerCase()}\u003e \u003cspan\u003e{myData.toLowerCase()}\u003c/span\u003e \u003c/h2\u003e) 样式的类名指定不能使用class，使用className 内敛样式要使用{{}}包裹，fontSize这种属性要写小驼峰 style={{color:'skyblue',fontSize:'24px'}} 不能有多个根标签，只能有一个根标签 标签必须闭合，自闭合也行 \u003cinput type=\"text\"/\u003e 如果小写字母开头，就将标签转化为 html 同名元素，如果 html 中无该标签对应的元素，就报错 如果是大写字母开头，react 就去渲染对应的组件，如果没有就报错 记几个 1.1 注释 写在花括号里 ReactDOM.render( \u003cdiv\u003e \u003ch1\u003e小丞\u003c/h1\u003e {/*注释...*/} \u003c/div\u003e, document.getElementById('example') ); 1.2 数组 JSX 允许在模板中插入数组，数组自动展开全部成员 var arr = [ \u003ch1\u003e小丞\u003c/h1\u003e, \u003ch2\u003e同学\u003c/h2\u003e, ]; ReactDOM.render( \u003cdiv\u003e{arr}\u003c/div\u003e, document.getElementById('example') ); ","date":"2022-06-15","objectID":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:2:1","tags":["前端","React"],"title":"React从入门到精通","uri":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"2. JSX 小练习 根据动态数据生成 li const data = ['A','B','C'] const VDOM = ( \u003cdiv\u003e \u003cul\u003e { data.map((item,index)=\u003e{ return \u003cli key={index}\u003e{item}\u003c/li\u003e }) } \u003c/ul\u003e \u003c/div\u003e ) ReactDOM.render(VDOM,document.getElementById('test')) 一定注意⚠️区分：【js语句(代码)】与【js表达式】 2.1 表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方 下面这些都是表达式： a a+b demo(1) arr.map() function test () {} 2.2 语句(代码)： 下面这些都是语句(代码)： if(){} for(){} switch(){case:xxxx} ","date":"2022-06-15","objectID":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:2:2","tags":["前端","React"],"title":"React从入门到精通","uri":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["算法"],"content":"LeetCode 0003.无重复字符的最长子串","date":"2022-06-07","objectID":"/leetcode-0003.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","tags":["leetcode","算法"],"title":"力扣 0003.无重复字符的最长子串","uri":"/leetcode-0003.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["算法"],"content":"3.无重复字符的最长子串 问题 给定一个字符串s,请你找出其中不含有重复字符的最长子串的长度。 示例1: 输入: s = \"abcabcbb\" 输出: 3 解释:因为无重复字符的最长子串是\"abo\",所以其长度为3。 示例2: 输入: s=\"bbbbb\" 输出: 1 解释:因为无重复字符的最长子串是\"b\",所以其长度为1。 示例3: 输入: s=\"pwwkew\" 输出: 3 解释:因为无重复字符的最长子串是\"wke\",所以其长度为3。 请注意,你的答案必须是子串的长度,\"pwke\"是一个子序列,不是子 串。 ","date":"2022-06-07","objectID":"/leetcode-0003.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/:1:0","tags":["leetcode","算法"],"title":"力扣 0003.无重复字符的最长子串","uri":"/leetcode-0003.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["算法"],"content":"法一：滑动窗口+哈希集合判断重复 var lengthOfLongestSubstring = function(s) { let set = new Set(); //创建一个set集合 let i = 0 ,j = 0; //创建两个指针,i指针随着for循环遍历字符串，j指针指向字符串的开头,即滑动窗口 let maxLength = 0; //记录最大长度 if(s.length === 0){ return 0; } for(let i = 0; i\u003c s.length; i++){ if(!set.has(s[i])){ //如果set理没有s[i]，说明目前为止没有重复的字符 set.add(s[i]); //把它添加到set里 maxLength = Math.max(maxLength,set.size); //更新最大不重复字符的数量，如果比之前大就更新 }else{ while(set.has(s[i])){ //如果set里有s[i]，开始以下操作，直到set里没有s[i]为止 set.delete(s[j]); //从set里开始删除s[j] j++; //并且开始递增j，即把j指针右移 } set.add(s[i]); //set里没有之前重复的s[i]后，添加新的s[i],开始新的一轮 } } return maxLength; //输出不含有重复字符的最长子串的长度 }; 时间复杂度： O(N)，N是字符串的长度，两个指针分别会遍历整个字符串一次。 空间复杂度： O(∣Σ∣)，字符集这里默认为ASCII码，即[0,128),所以字符集大小为128。 创建一个set集合。 创建两个指针,i指针随着for循环遍历字符串，j指针指向字符串的开头,即滑动窗口。 如果set理没有s[i]，说明目前为止没有重复的字符，把它添加到set里，然后更新最大不重复字符的数量，如果比之前大就更新。 如果set里有s[i]，则从set里开始删除s[j]，并且开始递增j，即把j指针右移，直到set里没有s[i]为止，添加新的s[i],开始新的一轮。 直到遍历完整个字符串，最后输出最大不重复字符的数量。 ","date":"2022-06-07","objectID":"/leetcode-0003.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/:1:1","tags":["leetcode","算法"],"title":"力扣 0003.无重复字符的最长子串","uri":"/leetcode-0003.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["算法"],"content":"法二：官方答案 var lengthOfLongestSubstring = function(s) { // 哈希集合，记录每个字符是否出现过 const occ = new Set(); const n = s.length; // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动 let rk = -1, ans = 0; for (let i = 0; i \u003c n; ++i) { if (i != 0) { // 左指针向右移动一格，移除一个字符 occ.delete(s.charAt(i - 1)); } while (rk + 1 \u003c n \u0026\u0026 !occ.has(s.charAt(rk + 1))) { // 不断地移动右指针 occ.add(s.charAt(rk + 1)); ++rk; } // 第 i 到 rk 个字符是一个极长的无重复字符子串 ans = Math.max(ans, rk - i + 1); } return ans; }; ","date":"2022-06-07","objectID":"/leetcode-0003.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/:1:2","tags":["leetcode","算法"],"title":"力扣 0003.无重复字符的最长子串","uri":"/leetcode-0003.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["算法"],"content":"LeetCode 0002.两数相加","date":"2022-06-06","objectID":"/leetcode-0002.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/","tags":["leetcode","算法"],"title":"力扣 0002.两数相加","uri":"/leetcode-0002.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"categories":["算法"],"content":"2.两数相加 问题 给你两个非空的链表,表示两个非负的整数。它们每位数字都是按照逆序的方式存储的,并且每个节点只能存储一位数字。 请你将两个数相加,并以相同形式返回一个表示和的链表。 信息 你可以假设除了数字0之外,这两个数都不会以0开头。 示例1: 输入: L1 = [2,4,3], L2 = [5,6,4] 输出: [7,0,8] 解释: 342 + 465 = 807. 示例2: 输入: L1= [0], L2 = [0] 输出: [0] 示例3: 输入: L1 = [9,9,9,9,9,9,9], L2 = [9,9,9,9] 输出: [8,9,9,9,0,0,0,1] ","date":"2022-06-06","objectID":"/leetcode-0002.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/:1:0","tags":["leetcode","算法"],"title":"力扣 0002.两数相加","uri":"/leetcode-0002.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"categories":["算法"],"content":"法一：利用官方构造函数设置结点 var addTwoNumbers = function(l1, l2) { let head = new ListNode(); //创建一个新结点head let tail = head; //head和tail都在新结点的位置 let carry = 0; //进位carry初始化为0 //同时遍历l1和l2直至到达它们的尾端 while(l1 != null || l2 != null){ let sum = 0; if(l1 != null){ sum += l1.val; //计算相同位置的和 l1 = l1.next; //将l1前进到下一个结点 } if(l2 != null){ sum += l2.val; //计算相同位置的和 l2 = l2.next; //将l2前进到下一个结点 } sum += carry; //与当前位置的进位值相加 tail.next = new ListNode(sum % 10) //创建一个数值为sum%10 取模的新结点，并将其设置为当前结点的下一个结点，答案链表处相应的数字为(n1+n2+carry)%10 carry = Math.floor(sum / 10); //新的进位符为(n1+n2+carry)/10 取整 tail = tail.next; //将当前结点前进到下一个结点 } if(carry \u003e 0){ tail.next = new ListNode(carry); //检查carry是否存在进位，是则添加一个数值为carry的新结点 } return head.next; } 时间复杂度： O(max(m,n))，其中m和n分别为两个链表的长度，我们要遍历两个链表的全部位置，而处理每个位置只需要O(1)时间。 空间复杂度： O(1)，返回值不计入空间复杂度。 由于输入的两个链表都是逆序存储数字的位数的，因此两个链表中同一位置的数字可以直接相加。 我们同时遍历两个链表，逐位计算它们的和，并与当前位置的进位值相加。 创建一个数值为sum%10 取模的新结点tail，并将其设置为当前结点的下一个结点，答案链表处相应的数字为(n1+n2+carry)%10 新的进位符为(n1+n2+carry)/10 取整 此外，链表遍历结束后，检查carry是否存在进位，是则添加一个数值为carry的新结点 ","date":"2022-06-06","objectID":"/leetcode-0002.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/:2:0","tags":["leetcode","算法"],"title":"力扣 0002.两数相加","uri":"/leetcode-0002.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"categories":["算法"],"content":"官方构造函数 function ListNode(val, next) { this.val = val === undefined ? 0 : val this.next = next === undefined ? null : next } 利用构造函数，生成结点，把链表里的数存进去 tail.next = new ListNode(sum % 10) ","date":"2022-06-06","objectID":"/leetcode-0002.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/:2:1","tags":["leetcode","算法"],"title":"力扣 0002.两数相加","uri":"/leetcode-0002.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"categories":["算法"],"content":"法二：官方答案 var addTwoNumbers = function(l1, l2) { let head = null, tail = null; //当前结点初始化为空结点 let carry = 0; //进位carry初始化为0 while(l1 != null || l2 != null){ //同时遍历l1和l2直至到达它们的尾端 const n1 = l1 ? l1.val : 0; const n2 = l2 ? l2.val : 0; const sum = n1 + n2 +carry; //逐位计算相同位置的和，并与当前位置的进位值相加 if(!head){ head = tail = new ListNode(sum % 10); //让head停在第一个结点的位置，tail同下 }else{ tail.next = new ListNode(sum % 10); //创建一个数值为sum%10 取模的新结点，答案链表处相应的数字为(n1+n2+carry)%10 tail = tail.next; //将当前结点前进到下一个结点 } carry = Math.floor(sum / 10); //新的进位符为(n1+n2+carry)/10 取整 if(l1){ l1 = l1.next; //将l1前进到下一个结点 } if(l2){ l2 = l2.next; //将l1前进到下一个结点 } } if(carry \u003e 0){ tail.next = new ListNode(carry); } return head; }; ","date":"2022-06-06","objectID":"/leetcode-0002.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/:3:0","tags":["leetcode","算法"],"title":"力扣 0002.两数相加","uri":"/leetcode-0002.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"categories":["算法"],"content":"LeetCode 0001.两数之和","date":"2022-06-05","objectID":"/leetcode-0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","tags":["leetcode","算法"],"title":"力扣 0001.两数之和","uri":"/leetcode-0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"categories":["算法"],"content":"1.两数之和 问题 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。 信息 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 示例 2： 输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3： 输入：nums = [3,3], target = 6 输出：[0,1] ","date":"2022-06-05","objectID":"/leetcode-0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/:1:0","tags":["leetcode","算法"],"title":"力扣 0001.两数之和","uri":"/leetcode-0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"categories":["算法"],"content":"法一：暴力解法 var twoSum = function(nums, target) { for(let i = 0,len = nums.length; i \u003c len; i++){ for(let j = i+1; j \u003c len; j++){ if((target - nums[i]) == nums[j]){ return [i,j]; } } } return []; }; 时间复杂度： O(N2)，其中 N是数组中的元素数量。对于每一个元素 x，我们可以 O(1) 地寻找 target - x。两个循环，所以是O(N2)。 空间复杂度： O(1) 简单粗暴,2遍for循环逐个遍历判断。 ","date":"2022-06-05","objectID":"/leetcode-0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/:2:0","tags":["leetcode","算法"],"title":"力扣 0001.两数之和","uri":"/leetcode-0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"categories":["算法"],"content":"法二：哈希表（官方答案） var twoSum = function(nums, target) { let map = new Map(); for(let i = 0; i \u003c nums.length; i++){ if(map.has(target - nums[i])){ return [map.get(target - nums[i]),i]; }else{ map.set(nums[i],i); } } return []; } 时间复杂度： O(N)，其中 N是数组中的元素数量。对于每一个元素 x，我们可以 O(1) 地寻找 target - x。 空间复杂度： O(N)，其中 N是数组中的元素数量。主要为哈希表的开销。 一遍for循环搞定,将数字存在哈希表的键值对中,并判断target-nums[i]的结果在哈希表键值对中是否存在,是则说明找到匹配数字。 我们遍历到数字a时,用target减去a,就会得到b,若b存在于哈希表中,我们就可以直接返回结果了。若b不存在,那么我们需要将a存入哈希表,好让后续遍历的数字使用。 ","date":"2022-06-05","objectID":"/leetcode-0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/:3:0","tags":["leetcode","算法"],"title":"力扣 0001.两数之和","uri":"/leetcode-0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"categories":["算法"],"content":"LeetCode 刷题预备知识","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"时间复杂度 ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:1:0","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"空间复杂度 ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:2:0","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"链表基础知识 链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。 链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。 使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。 但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的存取往往要在不同的排列顺序中转换。 链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。 链表有很多种不同的类型：单向链表，双向链表以及循环链表。 ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:3:0","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"二叉树(BT,Binary Tree) ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:4:0","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"满二叉树(Full Binary Tree) 叶子结点只能出现在最下层，其他层所有结点均有左子树和右子树，且所有层都达到该层能拥有的最大结点树数。它是完全二叉树的一种特殊情况。 官方定义： 如果一颗二叉树的结点要么是叶子结点，要么他有两个子结点，这样的树就是满二叉树。 ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:4:1","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"完全二叉树(Complete Binary Tree) 叶子结点只能出现在最下层和次下层，其他层所有结点均有左子树和右子树，且最下层的叶子结点集中在树的左部。 官方定义： 一颗深度为h的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这颗二叉树称为完全二叉树。 ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:4:2","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"二叉搜索树(BST,Binary Search Tree) 每个结点的左子树中所有结点的值均小于该结点的值，右子树中所有结点的值均大于该结点。 ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:5:0","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"二分搜索基础知识 练习： 给定一个 n个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1: 输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 示例 2: 输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:6:0","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"法一： var search = function(nums, target) { //定义左指针和右指针分别指向开头和结尾 let left =0, right = nums.length - 1; //当left\u003c=right while(left \u003c= right){ //mid=(left+right)/2,之所以写成下面的形式是防止超出整型范围，防止溢出。 mid = Math.floor(left + (right - left)/2); //如果找到了，就输出 if(nums[mid] == target){ return mid; //如果目标比mid小，要把右半边舍弃 }else if(target \u003c nums[mid]){ right = mid - 1;//mid以及mid右边都舍弃 //如果目标比mid大，要把左半边舍弃 }else{ left = mid + 1;//mid以及mid左半边都舍弃 } } //没找到输出-1 return -1; }; ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:6:1","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"Set基础知识 //创建一个Set const numberSet = new Set(); //添加，set不会添加重复的值 numberSet.add(1); //删除,成功返回ture，失败返回false numberSet.delete(1); //判断set里是否有这个值，有返回ture，没有返回false numberSet.has(1); //输出set里有几个元素 numberSet.size //遍历set中所有元素 numberSet.forEach(number=\u003e console.log(number)) // console.log(numberSet); 练习： //1.判断下面这段代码最终输出的值 const set = new Set(); set.add(1); set.add(1); set.add(\"1\"); console.log(set) 输出：{1,\"1\"} ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:7:0","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"Map基础知识 //创建一个Map const person = new Map(); //添加,如果重复set，会覆盖原来的值 person.set(\"name\",\"milo\"); person.set(\"age\",18); person.set(\"hooby\",[\"看老毕和鱼皮的视频\",\"睡觉\",\"打CSGO\"]) //删除,成功返回ture，失败返回false person.delete(\"age\") //获取Map里的某个值 person.get(\"name\"); //判断set里是否有这个值，有返回ture，没有返回false person.has(\"age\"); //输出set里有几个元素 person.size //遍历set中所有元素 person.forEach(person=\u003e console.log(person)) // console.log(person); 练习： //2.创建一个map，并且添加如下数据：1:“北京”，2:“上海”，3:“杭州”，（0，1，2均为数字）。然后删除掉第一个元素。 const cities = new Map(); cities.set(1,\"北京\"); cities.set(2,\"上海\"); cities.set(3,\"杭州\"); console.log(cities); 输出：{1 =\u003e '北京', 2 =\u003e '上海', 3 =\u003e '杭州'} cities.delete(1); console.log(cities); 输出：{2 =\u003e '上海', 3 =\u003e '杭州'} ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:8:0","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"let和const let和const的区别： Let可以重新赋值，Const不可以。 var a = 1; console.log(a); var b = \"hello\"; console.log(b); //let可以重新赋值 let c = 10; c = c + 1 ; console.log(c); //const不可以重新赋值。会报错 const d = \"hello\"; d = d + \"world\"; console.log(d); var和let、const的区别： var成功重复声明变量，let和const不可以 var productPrice = 5.99; // line 1000 var productPrice = 9.99; //重复声明了变量 // line 5000 productPrice++; console.log(productPrice); 输出：10.99 var的作用域范围是函数作用域范围 var price =1; function setPrice() { price++; } setPrice(); console.log(price) 输出：2 function setPrice() { var price =1; //而把var写在函数里面，外面的console.log就识别不到var price++; } setPrice(); console.log(price) 输出：Uncaught ReferenceError: price is not defined var price =1; function setPrice() { var price = 10; console.log(price); //var是函数作用域，所以这个console能访问到外面的也能访问到函数里的price console.log(window.price); //访问全局的price } setPrice(); console.log(price) 输出：10 1 1 let和const的作用域范围是块作用域 for(var i = 0; i \u003c 5; i++) {} console.log(i) //var是函数作用域，而for是块不是函数，所以var的i出了for这个块作用域，依然占用这个变量名，局部变量造成了全局污染。 输出：5 for(let i = 0; i \u003c 5; i++) {} console.log(i) //let是块作用域，就解决了局部变量污染全局变量的问题。 输出：Uncaught ReferenceError: i is not defined const price = 10; if(price \u003c 59){ const deliverFee = 5; price += deliverFee; } console.log(price); 输出：Uncaught TypeError: Assignment to constant variable. 解释：const不能重新赋值 let price = 10; if(price \u003c 59){ const deliverFee = 5; price += deliverFee; } console.log(price); console.log(deliverFee); 输出：15 Uncaught TypeError: Assignment to constant variable. 解释：let可以重复赋值,const是块作用域，所以最后一个console无法访问deliverFee 练习： 第一题：用let或const改写这段使用var的旧程序 var subtotal = 19.9; var tax = 0.13; var total = subtotal * ( 1 + tax); console.log(total) 输出：22.487 const subtotal = 19.9; const tax = 0.13; const total = subtotal * ( 1 + tax); console.log(total) 输出：22.487 let subtotal = 19.9; let tax = 0.13; let total = subtotal * ( 1 + tax); console.log(total) 输出：22.487 练习： 第二题：用let或const改写这段使用var的旧程序（注意函数作用域和块作用域的区别，必要时需要改变部分代码） 如果成绩哎60分以上，则课程pass var point = 95; if(point \u003e= 60){ var pass = true; } console.log(pass); 输出：true let point = 95; let pass = false; if(point \u003e= 60){ pass = true; } console.log(pass); 输出：true let point = 95; if(point \u003e= 60){ pass = true; console.log(pass); } 输出：true ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:9:0","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["前端"],"content":"JS从入门到精通","date":"2022-06-03","objectID":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/","tags":["前端","JS"],"title":"JS从入门到精通","uri":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":" 引用 笔记链接 尚硅谷最新版JavaScript基础全套教程完整版(140集实战教学,JS从入门到精通) ","date":"2022-06-03","objectID":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:0:0","tags":["前端","JS"],"title":"JS从入门到精通","uri":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"目录 01_JS 简介 02_JS基础 03_JS运算 04_流程控制05-对象 06_函数 07_作用域 08_构造函数与原型对象 09_数组 10_call, apply 和 arguments 11_Date和Math 12_包装类和字符串 13_正则表达式 14_DOM 15_事件对象 16_滚轮事件与键盘事件 17_BOM 18_定时调用与延时调用 19_JSON 部分内容如下： JS简介 ","date":"2022-06-03","objectID":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:0:1","tags":["前端","JS"],"title":"JS从入门到精通","uri":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"1、什么是语言 计算机就是一个由人来控制的机器，人让它干嘛，它就得干嘛。 我们要学习的语言就是人和计算机交流的工具，人类通过语言来控制、操作计算机。 编程语言和我们说的中文、英文本质上没有区别，只是语法比较特殊。 语言的发展： 纸带机：机器语言 汇编语言：符号语言 现代语言：高级语言 ","date":"2022-06-03","objectID":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:1:0","tags":["前端","JS"],"title":"JS从入门到精通","uri":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"2、JS起源 JavaScript诞生于1995年，它的出现主要是用于处理网页中的前端验证。 所谓的前端验证，就是指检查用户输入的内容是否符合一定的规则。 比如：用户名的长度，密码的长度，邮箱的格式等。 ","date":"2022-06-03","objectID":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:2:0","tags":["前端","JS"],"title":"JS从入门到精通","uri":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"3、JS简史 JavaScript是由网景公司发明，起初命名为LiveScript，后来由于SUN公司的介入更名为了JavaScript。 1996年微软公司在其最新的IE3浏览器中引入了自己对JavaScript的实现JScript。 于是在市面上存在两个版本的JavaScript，一个网景公司的JavaScript和微软的JScript。 为了确保不同的浏览器上运行的JavaScript标准一致，所以几个公司共同定制了JS的标准名命名为ECMAScript。 时间表 年份 事件 1995年 网景公司开发了JavaScript 1996年 微软发布了和JavaScript兼容的JScript 1997年 ECMAScript第1版（ECMA-262） 1998年 ECMAScript第2版 1998年 DOM Level1的制定 1998年 新型语言DHTML登场 1999年 ECMAScript第3版 2000年 DOM Level2的制定 2002年 ISO/IEC16262：2002的确立 2004年 DOM Level3的制定 2005年 新型语言AJAX登场 2009年 ECMAScript第5版 2009年 新型语言HTML5登场 ","date":"2022-06-03","objectID":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:3:0","tags":["前端","JS"],"title":"JS从入门到精通","uri":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"4、实现 ECMAScript是一个标准，而这个标准需要由各个厂商去实现。 不同的浏览器厂商对该标准会有不同的实现。 浏览器 JavaScript实现方式 FireFox SpiderMonkey Internet Explorer JScript/Chakra Safari JavaScriptCore Chrome v8 Carakan Carakan 我们已经知道ECMAScript是JavaScript标准。所以一般情况下，这两个词我们认为是一个意思。 但是实际上JavaScript的含义却要更大一些。 一个完整的JavaScript实现应该由以下三个部分构成： ","date":"2022-06-03","objectID":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:4:0","tags":["前端","JS"],"title":"JS从入门到精通","uri":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"5、学习内容 我们已经知道了一个完整的JavaScript实现包含了三个部分：ECMAScript、DOM和BOM。 由此我们也知道了我们所要学习的内容就是这三部分。 ECMAScript DOM BOM ","date":"2022-06-03","objectID":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:5:0","tags":["前端","JS"],"title":"JS从入门到精通","uri":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"6、JS的特点 解释型语言 类似于C和Java的语法结构 动态语言 基于原型的面向对象 ","date":"2022-06-03","objectID":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:6:0","tags":["前端","JS"],"title":"JS从入门到精通","uri":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"7、HelloWorld ","date":"2022-06-03","objectID":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:7:0","tags":["前端","JS"],"title":"JS从入门到精通","uri":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"控制浏览器弹出一个警告框 alert(\"Hello World!\"); ","date":"2022-06-03","objectID":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:7:1","tags":["前端","JS"],"title":"JS从入门到精通","uri":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"让计算机在页面中输出一个内容 document.write(\"Hello World!\"); ","date":"2022-06-03","objectID":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:7:2","tags":["前端","JS"],"title":"JS从入门到精通","uri":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"向控制台输出一个内容 console.log(\"Hello World!\"); ","date":"2022-06-03","objectID":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:7:3","tags":["前端","JS"],"title":"JS从入门到精通","uri":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"JS从入门到精通","date":"2022-05-15","objectID":"/htmlcss/","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":" 引用 笔记链接 尚硅谷Web前端HTML5\u0026CSS3初学者零基础入门全套完整版学习笔记 ","date":"2022-05-15","objectID":"/htmlcss/:0:0","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"目录 01_前端简介.md 02_前端开发准备.md 03_字符实体与语义标签.md 04_CSS语法与选择器.md 05_样式继承与其他概念.md 06_盒模型.md 07_实战练习.md 08_盒模型补径场实战.md 09_浮动.md 10_高度塌陷与BFC.md 11 定位.md 12_字体.md 13_背景.md 14雪碧图与渐变.md 15_表格.md 16_过渡与动画.md 17_变形:平转与缩放.md 18_less 简介.md 19_弹性盒简介.md 20_像素与视口.md 21_媒体查询.md 部分内容如下： 前端简介 ","date":"2022-05-15","objectID":"/htmlcss/:0:1","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"1. 软件的分类 ","date":"2022-05-15","objectID":"/htmlcss/:1:0","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"1.1. 系统软件 Windows Linux macOS ","date":"2022-05-15","objectID":"/htmlcss/:1:1","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"1.2. 应用软件 Office QQ ","date":"2022-05-15","objectID":"/htmlcss/:1:2","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"1.3. 游戏软件 绝地求生 王者荣耀 ","date":"2022-05-15","objectID":"/htmlcss/:1:3","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"2. 客户端与服务器 通常情况下，现在的软件一般由两个部分组成： 客户端：用户通过客户端来使用软件。 服务器：服务器负责在远程处理业务逻辑。 ","date":"2022-05-15","objectID":"/htmlcss/:2:0","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"2.1. 服务器 服务器开发的语言： Java PHP C# Python Node.js …… ","date":"2022-05-15","objectID":"/htmlcss/:2:1","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"2.2. 客户端 客户端的形式 文字客户端：占老的方式，通过命令行来使用软件 图形化界面：通过点击拖动等来使用软件。Windows 中、macOS 中、Android、iOS 中的大部分应用。（C/S 架构） 网页：通过访问网页来使用软件。所有的网站都属于这个范畴。（B/S 架构） ","date":"2022-05-15","objectID":"/htmlcss/:2:2","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"3. 网页的特点 相较于传统的图形化界面，网页具有如下一些优点： 不需要安装 无需更新 跨平台 网页中使用的语言： HTML、CSS、JavaScript ","date":"2022-05-15","objectID":"/htmlcss/:3:0","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"4. 网页简史 蒂姆·伯纳斯·李爵士，万维网的发明人。 1991 年 8 月 6 日，世界上第一个服务器和第一个网站在欧洲核子研究中心上线。 第一个网站：http://info.cern.ch/hypertext/WWW/TheProject.html ","date":"2022-05-15","objectID":"/htmlcss/:4:0","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"5. 浏览器和网页 有了浏览器我们只需要一个网址便可以访问任何的网站。 而浏览器中所显示的内容正是我们所说的网页。 网页原本的样子： ... \u003c!--无障碍占位--\u003e \u003cdiv id=\"J_accessibility\"\u003e\u003c/div\u003e \u003c!--顶通占位 --\u003e \u003cdiv id=\"J_promotional-top\"\u003e\u003c/div\u003e \u003cdiv id=\"shortcut\"\u003e \u003cdiv class=\"w\"\u003e \u003cul class=\"fl\" clstag=\"h|keycount|head|topbar_01\"\u003e \u003cli class=\"dropdown\" id=\"ttbar-mycity\"\u003e\u003c/li\u003e \u003c/ul\u003e \u003cul class=\"fr\"\u003e \u003cli class=\"fore1 dropdown\" id=\"ttbar-login\" clstag=\"h|keycount|head|topbar_02\" \u003e \u003ca href=\"//passport.jd.com/uc/login?ReturnUrl=https%3A%2F%2Fwww.jd.com%2F\" class=\"link-login\" \u003e你好，请登录\u003c/a \u003e\u0026nbsp;\u0026nbsp;\u003ca href=\"//reg.jd.com/reg/person?ReturnUrl=https%3A//www.jd.com/\" class=\"link-regist style-red\" \u003e免费注册\u003c/a \u003e \u003c/li\u003e \u003cli class=\"spacer\"\u003e\u003c/li\u003e \u003cli class=\"fore2\" clstag=\"h|keycount|head|topbar_03\"\u003e \u003cdiv class=\"dt\"\u003e \u003ca target=\"_blank\" href=\"//order.jd.com/center/list.action\" \u003e我的订单\u003c/a \u003e \u003c/div\u003e \u003c/li\u003e \u003cli class=\"spacer\"\u003e\u003c/li\u003e \u003cli class=\"fore3 dropdown\" id=\"ttbar-myjd\" clstag=\"h|keycount|head|topbar_04\" \u003e \u003cdiv class=\"dt cw-icon\"\u003e \u003ca target=\"_blank\" href=\"//home.jd.com/\"\u003e我的京东\u003c/a \u003e\u003ci class=\"iconfont\"\u003e\u0026#xe610;\u003c/i\u003e\u003ci class=\"ci-right\"\u003e\u003cs\u003e◇\u003c/s\u003e\u003c/i\u003e \u003c/div\u003e \u003cdiv class=\"dd dropdown-layer\"\u003e\u003c/div\u003e \u003c/li\u003e \u003cli class=\"spacer\"\u003e\u003c/li\u003e \u003cli class=\"fore4\" clstag=\"h|keycount|head|topbar_05\"\u003e \u003cdiv class=\"dt\"\u003e \u003ca target=\"_blank\" href=\"//vip.jd.com/\"\u003e京东会员\u003c/a\u003e \u003c/div\u003e \u003c/li\u003e \u003cli class=\"spacer\"\u003e\u003c/li\u003e \u003cli class=\"fore5\" clstag=\"h|keycount|head|topbar_06\"\u003e \u003cdiv class=\"dt\"\u003e\u003ca target=\"_blank\" href=\"//b.jd.com/\"\u003e企业采购\u003c/a\u003e\u003c/div\u003e \u003c/li\u003e \u003cli class=\"spacer\"\u003e\u003c/li\u003e \u003cli class=\"fore8 dropdown\" id=\"ttbar-serv\" clstag=\"h|keycount|head|topbar_07\" \u003e \u003cdiv class=\"dt cw-icon\"\u003e 客户服务\u003ci class=\"iconfont\"\u003e\u0026#xe610;\u003c/i \u003e\u003ci class=\"ci-right\"\u003e\u003cs\u003e◇\u003c/s\u003e\u003c/i\u003e \u003c/div\u003e \u003cdiv class=\"dd dropdown-layer\"\u003e\u003c/div\u003e \u003c/li\u003e \u003cli class=\"spacer\"\u003e\u003c/li\u003e \u003cli class=\"fore9 dropdown\" id=\"ttbar-navs\" clstag=\"h|keycount|head|topbar_08\" \u003e \u003cdiv class=\"dt cw-icon\"\u003e 网站导航\u003ci class=\"iconfont\"\u003e\u0026#xe610;\u003c/i \u003e\u003ci class=\"ci-right\"\u003e\u003cs\u003e◇\u003c/s\u003e\u003c/i\u003e \u003c/div\u003e \u003cdiv class=\"dd dropdown-layer\"\u003e\u003c/div\u003e \u003c/li\u003e \u003cli class=\"spacer\"\u003e\u003c/li\u003e \u003cli class=\"fore10 mobile\" id=\"J_mobile\" clstag=\"h|keycount|head|topbar_09\" \u003e \u003cdiv class=\"dt mobile_txt\"\u003e手机京东\u003c/div\u003e \u003cdiv class=\"mobile_static\"\u003e \u003cdiv class=\"mobile_static_qrcode\"\u003e\u003c/div\u003e \u003c/div\u003e \u003cdiv id=\"J_mobile_pop\" class=\"mod_loading mobile_pop\"\u003e\u003c/div\u003e \u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003c/div\u003e ... 浏览器渲染后的样子： 前端工程师负责编写网页的源代码。 浏览器负责将网页渲染成我们想要的样子。 ","date":"2022-05-15","objectID":"/htmlcss/:5:0","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"5.1. 浏览器的问题 市面上存在有很多不同的浏览器。 在万维网的初期，网页编写并没有标准。 于是就出现了这种情况： ","date":"2022-05-15","objectID":"/htmlcss/:5:1","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"5.2. W3C 的建立 伯纳斯李 1994 年建立万维网联盟（W3C） W3C 的出现为了制订网页开发的标准，以使同一个网页在不同的浏览器中有相同的效果。 所以，我们需要制订我们编写的网页都需要遵循 W3C 的规范！ ","date":"2022-05-15","objectID":"/htmlcss/:5:2","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"5.3. 网页的结构思想 根据 W3C 标准，一个网页主要由三部分组成：结构、表现还有行为。 结构、表现、行为 结构（骨架）：HTML 用于描述页面的结构 表现（皮肤）：CSS 用于控制页面中元素的样式 行为（交互）：JavaScript 用于响应用户操作 ","date":"2022-05-15","objectID":"/htmlcss/:5:3","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"6. 网页的基本结构 ","date":"2022-05-15","objectID":"/htmlcss/:6:0","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"6.1. 迭代 网页的版本 HTML4 XHTML2.0 HTML5 ","date":"2022-05-15","objectID":"/htmlcss/:6:1","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"6.2. 文档声明（doctype） 文档声明用来告诉浏览器当前网页的版本 \u003c!-- html5的文档声明 --\u003e \u003c!DOCTYPE html\u003e \u003c!-- 或者 --\u003e \u003c!DOCTYPE html\u003e ","date":"2022-05-15","objectID":"/htmlcss/:6:2","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"6.3. 字符编码 所有的数据在计算机中存储时都是以二进制形式存储的，文字也不例外。 所以一段文字在存储到内存中时，都需要转换为二进制编码当我们读取这段文字时，计算机会将编码转换为字符，供我们阅读 编码 将字符转换为二进制码的过程称为编码 解码 将二进制码转换为字符的过程称为解码 字符集（charset） 编码和解码所采用的规则称为字符集（相当于密码本） 乱码 如果编码和解码所采用的字符集不同就会出现乱码问题。 可以通过 meta 标签来设置网页的字符集，避免乱码问题 \u003cmeta charset=\"utf-8\" /\u003e ","date":"2022-05-15","objectID":"/htmlcss/:6:3","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"6.4. 常见的字符集 ASCII ASCII(American Standard Code for Information Interchange)：美国信息交换标准代码 在所有字符集中，最知名的可能要数被称为 ASCII 的8 位字符了。美国信息交换标准代码是由美国国家标准学会(American National Standard Institute , ANSI )制定的，是一种标准的单字节字符编码方案，用于基于文本的数据。它最初是美国国家标准，供不同计算机在相互通信时用作共同遵守的西文字符编码标准，后来它被国际标准化组织（International Organization for Standardization, ISO）定为国际标准，称为 ISO 646 标准。适用于所有拉丁文字字母 ASCII 码使用指定的 7 位或 8 位二进制数组合来表示 128 或 256 种可能的字符。标准 ASCII 码也叫基础 ASCII 码，使用 7 位二进制数（剩下的 1 位二进制为 0）来表示所有的大写和小写字母，数字 0 到 9、标点符号，以及在美式英语中使用的特殊控制字符 ASCII 码表：Ascii Table - ASCII character codes and html, octal, hex and decimal chart conversion ISO-8859-1 ISO-8859-1 编码是单字节编码，向下兼容 ASCII，其编码范围是 0x00-0xFF，0x00-0x7F 之间完全和 ASCII 一致，0x80-0x9F 之间是控制字符，0xA0-0xFF 之间是文字符号。 ISO 码表：HTML ISO-8859-1 参考手册 GB2312 GB2312（信息交换用汉字编码字符集）是由中国国家标准总局 1980 年发布。基本集共收入汉字 6763 个和非汉字图形字符 682 个。GB 2312 的出现，基本满足了汉字的计算机处理需要，它所收录的汉字已经覆盖中国大陆 99.75%的使用频率。 GBK GBK（即“国标”、“扩展”汉语拼音的第一个字母），汉字编码字符集。2000 年已被 GB18030-2000 国家强制标准替代。 2005 年 GB18030-2005 发布，替代了 GB18030-2000。 GBK 使用了双字节编码方案，其编码范围从 8140 至 FEFE（剔除 xx7F），共 23940 个码位，共收录了 21003 个汉字，完全兼容 GB2312-80 标准，支持国际标准 ISO/IEC10646-1 和国家标准 GB13000-1 中的全部中日韩汉字，并包含了 BIG5 编码中的所有汉字。 Big5 Big5，又称为大五码或五大码，是使用繁体中文（正体中文）社区中最常用的电脑汉字字符集标准，共收录 13,060 个汉字。 Big5 虽普及于台湾、香港与澳门等繁体中文通行区，但长期以来并非当地的国家/地区标准或官方标准，而只是业界标准。倚天中文系统、Windows 繁体中文版等主要系统的字符集都是以 Big5 为基准，但厂商又各自增加不同的造字与造字区，派生成多种不同版本。 UTF-8 UTF-8（8 位元，Universal Character Set/Unicode Transformation Format）是针对 Unicode 的一种可变长度字符编码，也叫万国码、统一码。它可以用来表示 Unicode 标准中的任何字符，而且其编码中的第一个字节仍与 ASCII 相容，使得原来处理 ASCII 字符的软件无须或只进行少部分修改后，便可继续使用。 UTF-16 UTF-16 是 Unicode 的其中一个使用方式。UTF-16 比起 UTF-8，好处在于大部分字符都以固定长度的字节（2 字节）储存，但 UTF-16 却无法兼容于 ASCII 编码。 Unicode Unicode 只是一组字符设定或者说是从数字和字符之间的逻辑映射的概念编码，但是它并没有指定代码点如何在计算机上存储。UCS4、UTF-8、UTF-16（UTF 后的数字代表编码的最小单位，如 UTF-8 表示最小单位 1 字节，所以它可以使用 1、2、3 字节等进行编码，UTF-16 表示最小单位 2 字节，所以它可以使用 2、4 字节进行编码）都是 Unicode 的编码方案。UTF-8 因可以兼容 ASCII 而被广泛使用。 如果把各种文字编码形容为各地的方言，那么 Unicode 就是世界各国合作开发的一种语言。 ","date":"2022-05-15","objectID":"/htmlcss/:6:4","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"6.5. HTML5 的基本结构 \u003c!-- 文档声明，声明当前网页的版本 --\u003e \u003c!DOCTYPE html\u003e \u003c!-- html的根标签（元素），网页中的所有内容都要写根元素的里边 --\u003e \u003chtml\u003e \u003c!-- head是网页的头部，head中的内容不会在网页中直接出现，主要用来帮助浏览器或搜索引擎来解析网页 --\u003e \u003chead\u003e \u003c!-- meta标签用来设置网页的元数据，这里meta用来设置网页的字符集，避免乱码问题 --\u003e \u003cmeta charset=\"utf-8\" /\u003e \u003c!-- title中的内容会显示在浏览器的标题栏，搜索引擎会主要根据title中的内容来判断网页的主要内容 --\u003e \u003ctitle\u003e网页的标题\u003c/title\u003e \u003c/head\u003e \u003c!-- body是htm1的子元素，表示网页的主体，网页中所有的可见内容都应该写在body里 --\u003e \u003cbody\u003e \u003c!-- h1网页的一级标题 --\u003e \u003ch1\u003e网页的大标题\u003c/h1\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-05-15","objectID":"/htmlcss/:6:5","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"前端学习计划","date":"2022-05-01","objectID":"/frontend/","tags":["前端","HTML","CSS","JS","Git","ES6","Ajax","axios","Promise","React","Webpack"],"title":"前端学习计划","uri":"/frontend/"},{"categories":["前端"],"content":"HTML、CSS（尚硅谷超哥） 视频链接：尚硅谷Web前端零基础入门HTML5+CSS3基础教程丨初学者从入门到精通 相关学习资料: 1.块级元素和行内元素：https://www.cnblogs.com/yc8930143/p/7237456.html 2.盒子模型： https://segmentfault.com/a/1190000013069516 3.CSS选择器： https://segmentfault.com/a/1190000013424772 ","date":"2022-05-01","objectID":"/frontend/:0:1","tags":["前端","HTML","CSS","JS","Git","ES6","Ajax","axios","Promise","React","Webpack"],"title":"前端学习计划","uri":"/frontend/"},{"categories":["前端"],"content":"JavaScript（尚硅谷超哥） 视频链接：尚硅谷JavaScript基础\u0026实战丨JS入门到精通全套完整版 相关学习资料: 1.现代JavaScript教程：https://zh.javascript.info/ ","date":"2022-05-01","objectID":"/frontend/:0:2","tags":["前端","HTML","CSS","JS","Git","ES6","Ajax","axios","Promise","React","Webpack"],"title":"前端学习计划","uri":"/frontend/"},{"categories":["前端"],"content":"JavaScript进阶高级部分（尚硅谷） 视频链接：https://www.bilibili.com/video/BV14s411E7qf ","date":"2022-05-01","objectID":"/frontend/:0:3","tags":["前端","HTML","CSS","JS","Git","ES6","Ajax","axios","Promise","React","Webpack"],"title":"前端学习计划","uri":"/frontend/"},{"categories":["前端"],"content":"ES6（尚硅谷） 视频链接：https://www.bilibili.com/video/BV1uK411H7on ","date":"2022-05-01","objectID":"/frontend/:0:4","tags":["前端","HTML","CSS","JS","Git","ES6","Ajax","axios","Promise","React","Webpack"],"title":"前端学习计划","uri":"/frontend/"},{"categories":["前端"],"content":"3小时Ajax入门到精通（尚硅谷） 视频链接：https://www.bilibili.com/video/BV1WC4y1b78y ","date":"2022-05-01","objectID":"/frontend/:0:5","tags":["前端","HTML","CSS","JS","Git","ES6","Ajax","axios","Promise","React","Webpack"],"title":"前端学习计划","uri":"/frontend/"},{"categories":["前端"],"content":"axios入门与源码解析（尚硅谷） 视频链接：尚硅谷Web前端axios入门与源码解析 ","date":"2022-05-01","objectID":"/frontend/:0:6","tags":["前端","HTML","CSS","JS","Git","ES6","Ajax","axios","Promise","React","Webpack"],"title":"前端学习计划","uri":"/frontend/"},{"categories":["前端"],"content":"Promise（尚硅谷） 视频链接：尚硅谷Web前端Promise教程从入门到精通 ","date":"2022-05-01","objectID":"/frontend/:0:7","tags":["前端","HTML","CSS","JS","Git","ES6","Ajax","axios","Promise","React","Webpack"],"title":"前端学习计划","uri":"/frontend/"},{"categories":["前端"],"content":"React（尚硅谷天禹） 视频链接：尚硅谷React技术全家桶全套完整版（零基础入门到精通/男神天禹老师亲授） ","date":"2022-05-01","objectID":"/frontend/:0:8","tags":["前端","HTML","CSS","JS","Git","ES6","Ajax","axios","Promise","React","Webpack"],"title":"前端学习计划","uri":"/frontend/"},{"categories":["前端"],"content":"Node.JS（尚硅谷） 视频链接：https://www.bilibili.com/video/BV1bs411E7pD ","date":"2022-05-01","objectID":"/frontend/:0:9","tags":["前端","HTML","CSS","JS","Git","ES6","Ajax","axios","Promise","React","Webpack"],"title":"前端学习计划","uri":"/frontend/"},{"categories":["前端"],"content":"Webpack（尚硅谷） 视频链接：https://www.bilibili.com/video/BV1e7411j7T5 ","date":"2022-05-01","objectID":"/frontend/:0:10","tags":["前端","HTML","CSS","JS","Git","ES6","Ajax","axios","Promise","React","Webpack"],"title":"前端学习计划","uri":"/frontend/"},{"categories":["前端"],"content":"Git（尚硅谷） 视频链接：https://www.bilibili.com/video/BV15J411973T ","date":"2022-05-01","objectID":"/frontend/:0:11","tags":["前端","HTML","CSS","JS","Git","ES6","Ajax","axios","Promise","React","Webpack"],"title":"前端学习计划","uri":"/frontend/"},{"categories":null,"content":"Milo ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"我 本科：上海工程技术大学 计算机科学与技术 硕士：上海工程技术大学 电子信息 研究方向-知识图谱、推荐系统 ","date":"0001-01-01","objectID":"/about/:0:1","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"Tags 爱打篮球、踢足球 喜欢吉他弹唱 前端开发 喜欢玩CSGO 不抽烟不喝酒不蹦迪 ","date":"0001-01-01","objectID":"/about/:0:2","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"技术评级 英语四六级 HTML\u0026CSS 入门 Less 业余 Javascript 入门 React 入门 Python 入门 Java 业余 保持谦逊 保持对新技术的不断探索 保持积极向上的心态 ","date":"0001-01-01","objectID":"/about/:0:3","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"各位留个友链格式如下： name = “Milo” url = “https://milo980412.github.io” logo = “https://milo980412.github.io/images/aniya.webp\" word = “保持谦逊，不断学习” Yulin Lewis \"不想当写手的码农不是好咸鱼_(xз」∠)_\" zsqw123 \"岳女士 yyds\" 东南dnf \"周顺大弟子\" dextercai \"Helo.😄\" ","date":"0001-01-01","objectID":"/friends/:0:0","tags":null,"title":"友链墙","uri":"/friends/"},{"categories":null,"content":"感谢投喂～💗 支付宝 微信 ","date":"0001-01-01","objectID":"/donate/:0:1","tags":null,"title":"赞赏","uri":"/donate/"}]