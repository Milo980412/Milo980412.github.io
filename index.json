[{"categories":["前端"],"content":"React从入门到精通","date":"2022-06-15","objectID":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/","tags":["前端","React"],"title":"React从入门到精通","uri":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":" 引用 B站视频 尚硅谷React技术全家桶全套完整版（零基础入门到精通/男神天禹） 引用 笔记链接 React技术全家桶 部分笔记内容如下： 01_基础知识以及 jsx 语法 📢 大家好 ，我是Milo同学，最近在学习 React，是我学习的第一个框架 先附上React官网 ，有很多问题都要通过查询官方文档来解决，要学会查文档~ ","date":"2022-06-15","objectID":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:0:0","tags":["前端","React"],"title":"React从入门到精通","uri":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"一、React 简介 ","date":"2022-06-15","objectID":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:1:0","tags":["前端","React"],"title":"React从入门到精通","uri":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"1. 关于 React 整几个面试题来认识一下~~ 什么是 React ？ React 是一个用于构建用户界面的 JavaScript 库。 是一个将数据渲染为 HTML 视图的开源 JS 库 它遵循基于组件的方法，有助于构建可重用的 UI 组件 它用于开发复杂的交互式的 web 和移动 UI React 有什么特点？ 声明式编码，组件化编码 使用虚拟 DOM 而不是真正的 DOM 它可以用服务器渲染 它遵循单向数据流或数据绑定 高效（优秀的Diffing算法、使用虚拟 DOM 而不是真正的 DOM） React 的一些主要优点？ 它提高了应用的性能（优秀的Diffing算法、使用虚拟 DOM 而不是真正的 DOM） 可以方便在客户端和服务器端使用 由于使用 JSX，代码的可读性更好 使用React，编写 UI 测试用例变得非常容易 ","date":"2022-06-15","objectID":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:1:1","tags":["前端","React"],"title":"React从入门到精通","uri":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"2. Hello React 首先需要引入几个 react 包，我直接用的是老师下载好的，核心库必须在扩展库前面引入！ React 核心库、操作 DOM 的 react 扩展库、将 jsx 转为 js 的 babel 库 \u003c!-- 准备好一个“容器” --\u003e \u003cdiv id=\"test\"\u003e\u003c/div\u003e \u003c!-- 引入react核心库 --\u003e \u003cscript type=\"text/javascript\" src=\"../js/react.development.js\"\u003e\u003c/script\u003e \u003c!-- 引入react-dom，用于支持react操作DOM --\u003e \u003cscript type=\"text/javascript\" src=\"../js/react-dom.development.js\"\u003e\u003c/script\u003e \u003c!-- 引入babel，用于将jsx转为js --\u003e \u003cscript type=\"text/javascript\" src=\"../js/babel.min.js\"\u003e\u003c/script\u003e /* 此处一定要写babel */ \u003cscript type=\"text/babel\" \u003e\u003c/script\u003e 然后在里创建虚拟DOM //1.创建虚拟DOM const VDOM = \u003ch1\u003eHello,React\u003c/h1\u003e //2.渲染虚拟DOM到页面 ReactDOM.render(VDOM,document.querySelector(\".test\")) 如果我创建两个虚拟DOM，渲染两次（注意⚠️） // 1.创建虚拟DOM const VDOM = \u003ch1\u003eHello,React\u003c/h1\u003e const VDOM2 = \u003ch1\u003eHello,Milo\u003c/h1\u003e // 2.渲染虚拟DOM到页面 ReactDOM.render(VDOM,document.getElementById('test')) ReactDOM.render(VDOM2,document.getElementById('test')) 由于渲染不是一个叠加操作，而是覆盖操作，页面只会渲染生成hello，milo的DOM操作！ ","date":"2022-06-15","objectID":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:1:2","tags":["前端","React"],"title":"React从入门到精通","uri":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"3. 虚拟 DOM 和真实 DOM 的两种创建方法 为什么不用js而使用jsx？ JS创建虚拟DOM太繁琐了，JSX更方便 3.1 JS 创建虚拟 DOM //1.创建虚拟DOM,创建嵌套格式的dom const VDOM=React.createElement('h1',{id:'title'},React.createElement('span',{},'hello,React')) //2.渲染虚拟DOM到页面 ReactDOM.render(VDOM,document.getElementById('test')) 3.2 Jsx 创建虚拟DOM //1.创建虚拟DOM const VDOM = ( /* 此处一定不要写引号，因为不是字符串 */ \u003ch1 id=\"title\"\u003e \u003cspan\u003eHello,React\u003c/span\u003e \u003c/h1\u003e ) //2.渲染虚拟DOM到页面 ReactDOM.render(VDOM,document.getElementById('test')) js 的写法并不是常用的，常用jsx来写，毕竟JSX更符合书写的习惯 3.3 虚拟DOM与真实DOM 关于虚拟DOM： 本质是Object类型的对象（一般对象） 虚拟DOM比较“轻”，真实DOM比较“重”，因为虚拟DOM是React内部在用，无需真实DOM上那么多的属性。 虚拟DOM最终会被React转化为真实DOM，呈现在页面上。 console.log('虚拟DOM',VDOM); //[Object Object] console.log(typeof VDOM); //object console.log(VDOM instanceof Object); //true const TDOM = document.getElementById('demo') console.log('虚拟DOM',VDOM); //[Object Object] console.log('真实DOM',TDOM); //\u003cdiv id=\"demo\"\u003e\u003c/div\u003e debugger; ","date":"2022-06-15","objectID":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:1:3","tags":["前端","React"],"title":"React从入门到精通","uri":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"二、jsx 语法 ","date":"2022-06-15","objectID":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:2:0","tags":["前端","React"],"title":"React从入门到精通","uri":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"1. jsx语法规则 定义虚拟DOM，不能使用“” 标签中混入JS表达式的时候使用{}，toLowerCase()方法可转化成小写 // 1.创建虚拟DOM const VDOM = ( \u003ch2 id={myId.toLowerCase()}\u003e \u003cspan\u003e{myData.toLowerCase()}\u003c/span\u003e \u003c/h2\u003e) 样式的类名指定不能使用class，使用className 内敛样式要使用{{}}包裹，fontSize这种属性要写小驼峰 style={{color:'skyblue',fontSize:'24px'}} 不能有多个根标签，只能有一个根标签 标签必须闭合，自闭合也行 \u003cinput type=\"text\"/\u003e 如果小写字母开头，就将标签转化为 html 同名元素，如果 html 中无该标签对应的元素，就报错 如果是大写字母开头，react 就去渲染对应的组件，如果没有就报错 记几个 1.1 注释 写在花括号里 ReactDOM.render( \u003cdiv\u003e \u003ch1\u003e小丞\u003c/h1\u003e {/*注释...*/} \u003c/div\u003e, document.getElementById('example') ); 1.2 数组 JSX 允许在模板中插入数组，数组自动展开全部成员 var arr = [ \u003ch1\u003e小丞\u003c/h1\u003e, \u003ch2\u003e同学\u003c/h2\u003e, ]; ReactDOM.render( \u003cdiv\u003e{arr}\u003c/div\u003e, document.getElementById('example') ); ","date":"2022-06-15","objectID":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:2:1","tags":["前端","React"],"title":"React从入门到精通","uri":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"2. JSX 小练习 根据动态数据生成 li const data = ['A','B','C'] const VDOM = ( \u003cdiv\u003e \u003cul\u003e { data.map((item,index)=\u003e{ return \u003cli key={index}\u003e{item}\u003c/li\u003e }) } \u003c/ul\u003e \u003c/div\u003e ) ReactDOM.render(VDOM,document.getElementById('test')) 一定注意⚠️区分：【js语句(代码)】与【js表达式】 2.1 表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方 下面这些都是表达式： a a+b demo(1) arr.map() function test () {} 2.2 语句(代码)： 下面这些都是语句(代码)： if(){} for(){} switch(){case:xxxx} ","date":"2022-06-15","objectID":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:2:2","tags":["前端","React"],"title":"React从入门到精通","uri":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["技术"],"content":"进程和线程的区别","date":"2022-06-08","objectID":"/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/","tags":["操作系统"],"title":"进程和线程的区别","uri":"/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["技术"],"content":"经典面试题 进程与线程之间有什么区别？ 扩展 什么是缓冲区溢出？ 进程之间如何进行交互？ 线程之间如何进行交互？ 面试时不可避免会被问到这个问题，Milo将自己的理解记录一下。 ","date":"2022-06-08","objectID":"/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/:1:0","tags":["操作系统"],"title":"进程和线程的区别","uri":"/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["技术"],"content":"类比理解 1.计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。 2.假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。 3.进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。 4.一个车间里，可以有很多工人。他们协同完成一个任务。 5.线程就好比车间里的工人。一个进程可以包括多个线程。 6.车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。 7.可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。 8.一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫\"互斥锁\"（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。 9.还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。 10.这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做\"信号量\"（Semaphore），用来保证多个线程不会互相冲突。 不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。 11.操作系统的设计，因此可以归结为三点： 以多进程形式，允许多个任务同时运行； 以多线程形式，允许单个任务分成不同的部分运行； 提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。 ","date":"2022-06-08","objectID":"/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/:2:0","tags":["操作系统"],"title":"进程和线程的区别","uri":"/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["技术"],"content":"面试回答 进程是程序在执行过程中分配和管理资源的基本单位，每一个进程都有自己的地址空间，至少有5种基本状态：初始态、执行态、等待状态、就需状态和终止状态 线程是CPU调度和分派的基本单位，它可与同属一个进程的其他线程共享进程所拥有的全部资源 联系 线程是进程的一部分，一个线程只能属于一个进程，而一个进程可以有多个线程 区别 进程是操作系统分配和管理资源的基本单位，线程是任务调度和执行的基本单位 进程有独立的地址空间，而线程只能共享所属进程的资源 进程之间的切换开销大，线程之间的切换开销小 线程是为了在系统层面实现并发，提高硬件利用率 进程是为隔离资源，保障一些资源崩溃了后被回收，不影响其他程序 扩展 缓冲区溢出：我们有个地方要输入用户名，本来是用来存数据的地方。 然后黑客把数据输入的特别长。这个长度超出了我们给数据存储的内存区，这时候跑到了 我们给程序分配的一部分内存中。黑客就可以通过这种办法将他所要运行的代码 写入到用户名框中，来植入进来。我们的解决方法就是，用用户名的长度来限制不要超过 用户名的缓冲区的大小来解决。 进程之间通过TCP/IP的端口来进行交互 线程的通信就比较简单，有一大块共享的内存，只要大家的指针是同一个就可以看到各自的内存 ","date":"2022-06-08","objectID":"/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/:3:0","tags":["操作系统"],"title":"进程和线程的区别","uri":"/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["算法"],"content":"LeetCode 0003.无重复字符的最长子串","date":"2022-06-07","objectID":"/leetcode-0003.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","tags":["leetcode","算法"],"title":"力扣 0003.无重复字符的最长子串","uri":"/leetcode-0003.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["算法"],"content":"3.无重复字符的最长子串 问题 给定一个字符串s,请你找出其中不含有重复字符的最长子串的长度。 示例1: 输入: s = \"abcabcbb\" 输出: 3 解释:因为无重复字符的最长子串是\"abo\",所以其长度为3。 示例2: 输入: s=\"bbbbb\" 输出: 1 解释:因为无重复字符的最长子串是\"b\",所以其长度为1。 示例3: 输入: s=\"pwwkew\" 输出: 3 解释:因为无重复字符的最长子串是\"wke\",所以其长度为3。 请注意,你的答案必须是子串的长度,\"pwke\"是一个子序列,不是子 串。 ","date":"2022-06-07","objectID":"/leetcode-0003.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/:1:0","tags":["leetcode","算法"],"title":"力扣 0003.无重复字符的最长子串","uri":"/leetcode-0003.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["算法"],"content":"法一：滑动窗口+哈希集合判断重复 var lengthOfLongestSubstring = function(s) { let set = new Set(); //创建一个set集合 let i = 0 ,j = 0; //创建两个指针,i指针随着for循环遍历字符串，j指针指向字符串的开头,即滑动窗口 let maxLength = 0; //记录最大长度 if(s.length === 0){ return 0; } for(let i = 0; i\u003c s.length; i++){ if(!set.has(s[i])){ //如果set理没有s[i]，说明目前为止没有重复的字符 set.add(s[i]); //把它添加到set里 maxLength = Math.max(maxLength,set.size); //更新最大不重复字符的数量，如果比之前大就更新 }else{ while(set.has(s[i])){ //如果set里有s[i]，开始以下操作，直到set里没有s[i]为止 set.delete(s[j]); //从set里开始删除s[j] j++; //并且开始递增j，即把j指针右移 } set.add(s[i]); //set里没有之前重复的s[i]后，添加新的s[i],开始新的一轮 } } return maxLength; //输出不含有重复字符的最长子串的长度 }; 时间复杂度： O(N)，N是字符串的长度，两个指针分别会遍历整个字符串一次。 空间复杂度： O(∣Σ∣)，字符集这里默认为ASCII码，即[0,128),所以字符集大小为128。 创建一个set集合。 创建两个指针,i指针随着for循环遍历字符串，j指针指向字符串的开头,即滑动窗口。 如果set理没有s[i]，说明目前为止没有重复的字符，把它添加到set里，然后更新最大不重复字符的数量，如果比之前大就更新。 如果set里有s[i]，则从set里开始删除s[j]，并且开始递增j，即把j指针右移，直到set里没有s[i]为止，添加新的s[i],开始新的一轮。 直到遍历完整个字符串，最后输出最大不重复字符的数量。 ","date":"2022-06-07","objectID":"/leetcode-0003.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/:1:1","tags":["leetcode","算法"],"title":"力扣 0003.无重复字符的最长子串","uri":"/leetcode-0003.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["算法"],"content":"法二：官方答案 var lengthOfLongestSubstring = function(s) { // 哈希集合，记录每个字符是否出现过 const occ = new Set(); const n = s.length; // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动 let rk = -1, ans = 0; for (let i = 0; i \u003c n; ++i) { if (i != 0) { // 左指针向右移动一格，移除一个字符 occ.delete(s.charAt(i - 1)); } while (rk + 1 \u003c n \u0026\u0026 !occ.has(s.charAt(rk + 1))) { // 不断地移动右指针 occ.add(s.charAt(rk + 1)); ++rk; } // 第 i 到 rk 个字符是一个极长的无重复字符子串 ans = Math.max(ans, rk - i + 1); } return ans; }; ","date":"2022-06-07","objectID":"/leetcode-0003.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/:1:2","tags":["leetcode","算法"],"title":"力扣 0003.无重复字符的最长子串","uri":"/leetcode-0003.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["工具"],"content":"Git基本命令","date":"2022-06-06","objectID":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","tags":["Git"],"title":"Git基本命令","uri":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":" 引用 笔记来源 小丞前端日记 ","date":"2022-06-06","objectID":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:0:0","tags":["Git"],"title":"Git基本命令","uri":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"引言 Git 作为目前最强大的代码管理工具，相信大家都很熟悉了。它在我们的日常工作中起着至关重要的作用，我们可以用它来实现多人开发。也可以用来方便我们自己，在我们坐车的时候，可以用手机看看自己刚刚上传的代码。这些都是不错的选择，下面我们就结合场景来学习一下 Git 的基本命令 ","date":"2022-06-06","objectID":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:1:0","tags":["Git"],"title":"Git基本命令","uri":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"场景实战 我们的第一个任务是：将代码提交到 Gitee / Github 远程仓库中 ","date":"2022-06-06","objectID":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:0","tags":["Git"],"title":"Git基本命令","uri":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"1. 创建远程代码仓库 首先我们需要创建一个远程仓库，这里我选择的是 Gitee ","date":"2022-06-06","objectID":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:1","tags":["Git"],"title":"Git基本命令","uri":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"2. 全局设置 Git 在使用 Git 之前，我们需要设置用户名和邮箱，以方便记录代码的提交者是谁 用户名 git config --global user.name \"your_username\" 邮箱 git config --global user.email \"your_email\" ","date":"2022-06-06","objectID":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:2","tags":["Git"],"title":"Git基本命令","uri":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"3. 创建本地代码仓库 在配置好全局设置后，我们可以新建一个文件夹，用来当作本地代码仓库 建好文件夹后，我们需要初始化代码仓库 git init 这时候在这个文件夹下就会创建一个隐藏的 .git 文件，这样就创建好了 ","date":"2022-06-06","objectID":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:3","tags":["Git"],"title":"Git基本命令","uri":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"4. 暂存文件 这时候我们在当前文件夹下创建一个文件 touch README.md 然后随意添加点文件内容 将修改的文件保存到暂存区 git add . . 表示目录下的全部文件，也就是提交所有 如果只想上传某个可以这样 git add README.md ","date":"2022-06-06","objectID":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:4","tags":["Git"],"title":"Git基本命令","uri":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"5. 提交修改 将文件保存到暂存区之后，我们需要将文件提交到本地仓库 git commit -m \"first commit\" 引号内容是我们此次提交的注释，解释这次提交修改的内容之类的 在某些考核的过程中，可能会限制代码提交的次数 我们可以将此次的修改加到上一次提交中 git commit --amend ","date":"2022-06-06","objectID":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:5","tags":["Git"],"title":"Git基本命令","uri":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"6. 与远程仓库建立连接 在推送代码之前我们需要与远程仓库建立连接，不然本地参考怎么知道上传到哪里呢？ git remote add origin 仓库地址 仓库地址在 Gitee 上可以查看 ","date":"2022-06-06","objectID":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:6","tags":["Git"],"title":"Git基本命令","uri":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"7. 推送代码 在提交代码到本地仓库后，我们需要将它推送到远程仓库中 git push -u origin master 注意：第一次推送分支时，加上 -u ，在推送分支内容的同时，会与远端的分支关联起来，下次提交不需 -u 可以直接 git push origin master ","date":"2022-06-06","objectID":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:7","tags":["Git"],"title":"Git基本命令","uri":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"8. 查看远程仓库 这时候我们可以在远程仓库上，看到自己刚刚上传的代码 这样我们就完成了我们的第一个任务，上传代码 接收第二个任务，现在我们的项目有两个开发人员，我们需要创建一个分支，用于平时的开发 ","date":"2022-06-06","objectID":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:8","tags":["Git"],"title":"Git基本命令","uri":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"9. 创建分支 创建分支可以保证各个功能的相对独立，不用一起修改同个分支的代码文件 我们可以先查看当前仓库下的所有分支 git branch 创建一个 dev 分支 git branch dev 切换到 dev 分支 git checkout \"dev\" 以上的分支操作，还可以采用其他的方法 创建分支并切换到该分支 git checkout -b \"分支名\" 也可以采用 switch （推荐） git switch -c \"分支名\" 切换分支也可以采用 switch git switch 分支名 然后我们可以通过切换到 dev 分支上，进行正常的提交推送，就像这样 ","date":"2022-06-06","objectID":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:9","tags":["Git"],"title":"Git基本命令","uri":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"10. 合并分支 平时我们在 dev 分支上开发，到一定时候是，我们需要将我们的分支合并到主干分支上 首先需要切换到 master 分支 git checkout master 然后合并 dev 分支 git merge dev 合并完成后要 push 到远程仓库 git push origin master ","date":"2022-06-06","objectID":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:10","tags":["Git"],"title":"Git基本命令","uri":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"11. 删除分支 当我们不再需要这个分支时，我们就可以删除它 git branch -D 分支名 这只是删除了本地的分支 我们还要删除远程仓库的分支 git push origin --delete 分支名 此时已删除成功 我们成功的学会了第二个任务，现在你的同事推送了代码我们需要同步一下 ","date":"2022-06-06","objectID":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:11","tags":["Git"],"title":"Git基本命令","uri":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"12. 拉取代码 直接拉取就好了 git pull 在我们多人开发的过程中，上传代码前一定要先拉取远程仓库的代码 以上就是一个拉取上传的完整操作了 下面是一些其他的命令，可以结合使用 ","date":"2022-06-06","objectID":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:12","tags":["Git"],"title":"Git基本命令","uri":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"13. 其他命令 1. 查看文件状态 git status 2. 查看提交历史记录 git log 3. 代码回滚 版本号可以在 gitee 上看到，也可以在 log 中看到 git checkout 版本号 4. 克隆项目 git clone 地址 指定克隆下来的文件位置 git clone git地址 '文件存放路径' 5. 储藏修改 把本地修改储藏起来，等恢复后再继续工作 git stash 6. 查看储藏信息 git stash list 7. 恢复储藏信息 git stash apply 8. 删除储藏内容 git stash drop ","date":"2022-06-06","objectID":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:13","tags":["Git"],"title":"Git基本命令","uri":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["算法"],"content":"LeetCode 0002.两数相加","date":"2022-06-06","objectID":"/leetcode-0002.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/","tags":["leetcode","算法"],"title":"力扣 0002.两数相加","uri":"/leetcode-0002.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"categories":["算法"],"content":"2.两数相加 问题 给你两个非空的链表,表示两个非负的整数。它们每位数字都是按照逆序的方式存储的,并且每个节点只能存储一位数字。 请你将两个数相加,并以相同形式返回一个表示和的链表。 信息 你可以假设除了数字0之外,这两个数都不会以0开头。 示例1: 输入: L1 = [2,4,3], L2 = [5,6,4] 输出: [7,0,8] 解释: 342 + 465 = 807. 示例2: 输入: L1= [0], L2 = [0] 输出: [0] 示例3: 输入: L1 = [9,9,9,9,9,9,9], L2 = [9,9,9,9] 输出: [8,9,9,9,0,0,0,1] ","date":"2022-06-06","objectID":"/leetcode-0002.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/:1:0","tags":["leetcode","算法"],"title":"力扣 0002.两数相加","uri":"/leetcode-0002.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"categories":["算法"],"content":"法一：利用官方构造函数设置结点 var addTwoNumbers = function(l1, l2) { let head = new ListNode(); //创建一个新结点head let tail = head; //head和tail都在新结点的位置 let carry = 0; //进位carry初始化为0 //同时遍历l1和l2直至到达它们的尾端 while(l1 != null || l2 != null){ let sum = 0; if(l1 != null){ sum += l1.val; //计算相同位置的和 l1 = l1.next; //将l1前进到下一个结点 } if(l2 != null){ sum += l2.val; //计算相同位置的和 l2 = l2.next; //将l2前进到下一个结点 } sum += carry; //与当前位置的进位值相加 tail.next = new ListNode(sum % 10) //创建一个数值为sum%10 取模的新结点，并将其设置为当前结点的下一个结点，答案链表处相应的数字为(n1+n2+carry)%10 carry = Math.floor(sum / 10); //新的进位符为(n1+n2+carry)/10 取整 tail = tail.next; //将当前结点前进到下一个结点 } if(carry \u003e 0){ tail.next = new ListNode(carry); //检查carry是否存在进位，是则添加一个数值为carry的新结点 } return head.next; } 时间复杂度： O(max(m,n))，其中m和n分别为两个链表的长度，我们要遍历两个链表的全部位置，而处理每个位置只需要O(1)时间。 空间复杂度： O(1)，返回值不计入空间复杂度。 由于输入的两个链表都是逆序存储数字的位数的，因此两个链表中同一位置的数字可以直接相加。 我们同时遍历两个链表，逐位计算它们的和，并与当前位置的进位值相加。 创建一个数值为sum%10 取模的新结点tail，并将其设置为当前结点的下一个结点，答案链表处相应的数字为(n1+n2+carry)%10 新的进位符为(n1+n2+carry)/10 取整 此外，链表遍历结束后，检查carry是否存在进位，是则添加一个数值为carry的新结点 ","date":"2022-06-06","objectID":"/leetcode-0002.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/:2:0","tags":["leetcode","算法"],"title":"力扣 0002.两数相加","uri":"/leetcode-0002.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"categories":["算法"],"content":"官方构造函数 function ListNode(val, next) { this.val = val === undefined ? 0 : val this.next = next === undefined ? null : next } 利用构造函数，生成结点，把链表里的数存进去 tail.next = new ListNode(sum % 10) ","date":"2022-06-06","objectID":"/leetcode-0002.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/:2:1","tags":["leetcode","算法"],"title":"力扣 0002.两数相加","uri":"/leetcode-0002.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"categories":["算法"],"content":"法二：官方答案 var addTwoNumbers = function(l1, l2) { let head = null, tail = null; //当前结点初始化为空结点 let carry = 0; //进位carry初始化为0 while(l1 != null || l2 != null){ //同时遍历l1和l2直至到达它们的尾端 const n1 = l1 ? l1.val : 0; const n2 = l2 ? l2.val : 0; const sum = n1 + n2 +carry; //逐位计算相同位置的和，并与当前位置的进位值相加 if(!head){ head = tail = new ListNode(sum % 10); //让head停在第一个结点的位置，tail同下 }else{ tail.next = new ListNode(sum % 10); //创建一个数值为sum%10 取模的新结点，答案链表处相应的数字为(n1+n2+carry)%10 tail = tail.next; //将当前结点前进到下一个结点 } carry = Math.floor(sum / 10); //新的进位符为(n1+n2+carry)/10 取整 if(l1){ l1 = l1.next; //将l1前进到下一个结点 } if(l2){ l2 = l2.next; //将l1前进到下一个结点 } } if(carry \u003e 0){ tail.next = new ListNode(carry); } return head; }; ","date":"2022-06-06","objectID":"/leetcode-0002.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/:3:0","tags":["leetcode","算法"],"title":"力扣 0002.两数相加","uri":"/leetcode-0002.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"categories":["前端"],"content":"Javascript中的高阶函数","date":"2022-06-05","objectID":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/","tags":["前端","JS"],"title":"Javascript中的高阶函数","uri":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"},{"categories":["前端"],"content":"高阶函数是指以函数作为参数的函数，并且可以将函数作为结果返回的函数。 ","date":"2022-06-05","objectID":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/:0:0","tags":["前端","JS"],"title":"Javascript中的高阶函数","uri":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"},{"categories":["前端"],"content":"1. 高阶函数 接受一个或多个函数作为输入 输出一个函数 至少满足以上一个条件的函数 在js的内置对象中同样存在着一些高阶函数，像数组的map，filter，reduce方法等，它们接受一个函数作为参数，并应用这个函数到列表的每一个元素 ","date":"2022-06-05","objectID":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/:1:0","tags":["前端","JS"],"title":"Javascript中的高阶函数","uri":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"},{"categories":["前端"],"content":"1.1 map map方法接收一个函数作为参数 ，遍历数组，并且返回一个新的数组，新的数组里的每个元素都执行map传入的函数。 let arr = [1, 2, 3, 4]; let arr1 = arr.map(item =\u003e item * 2) console.log(arr1);// [2, 4, 6, 8] 返回的是一个新数组arr1，==不改变原数组== 注意：如果传入的参数没有返回值，则数组的每一项都会是undefind 经典题目 console.log(['1','2','3'].map(parseInt)); 来看看上面这个代码输出什么 答案：[1, NaN, NaN] 解析 parseInt() 函数可解析一个字符串，并返回一个整数。 基数radix可选2到36之间的整数，当参数 radix 的值为 0，或没有设置该参数时，parseInt()会根据该字符串来判断数字的基数。 当忽略参数 radix , 默认的基数如下: 如果 字符串 以 “0x” 开头，parseInt() 会把 其余部分解析为十六进制的整数。 如果字符串以 0 开头，把其余部分解析为八进制或十六进制的数字。 如果字符串以 1 ~ 9 的数字开头，parseInt()将把它解析为十进制的整数 如果基数小于2或大于36，或者第一个非空白字符不能转换为数字，则返回NaN。 注意：基数可不是默认十进制 当我们把数组传入parseInt时，由于接收2个参数，会将数组的索引作为基数传给parseInt，所以实质上进行的是以下几步 parseInt('1', 0) parseInt('2', 1) parseInt('3', 2) 第一个parseInt，字符串为1，基数为0 被默认为十进制，所以返回1 第二个和第三个，因为基数不是0，且小于2，所以parseInt()会返回 NaN。 ","date":"2022-06-05","objectID":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/:1:1","tags":["前端","JS"],"title":"Javascript中的高阶函数","uri":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"},{"categories":["前端"],"content":"1.2 filter 用于筛选数组 filter方法接收一个函数作为参数，通过这个函数来指定筛选数组的规则，最后返回满足规则的新数组 在传入的函数中有3个参数可选 参数 描述 currentValue 必须。当前元素的值 index 可选。当前元素的索引值 arr 可选。当前元素属于的数组对象 注意： 不会检测空数组 不会改变原始数组 let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9] let arr1 = arr.filter(num =\u003e { return num \u003e 5 }) console.log(arr1);// [6, 7, 8, 9] ","date":"2022-06-05","objectID":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/:1:2","tags":["前端","JS"],"title":"Javascript中的高阶函数","uri":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"},{"categories":["前端"],"content":"1.3 reduce reduce能做的事情很多，但是我们平时都使用for循环之类的方法代替了，但是reduce真的高逼格 array.reduce(function(total, currentValue, currentIndex, arr), initialValue) 以上是在w3school中给出的reduce语法，这里我们常用的只有前面两个 参数 描述 total 必需。初始值, 或者计算结束后的返回值。 currentValue 必需。当前元素 let arr = [1, 2, 3, 4] let sum = arr.reduce((value, item) =\u003e { console.log(value, item); // 1 2 3 3 6 4 return value + item }) console.log(sum);// 10 从第四行的调试中可以看出reduce函数的执行过程，在没有初始值的情况下，将数组第一个值作为value第二个值作为item再依次往下遍历整个数组，将返回值作为value，数组的下一位作为item，直至遍历完成。 利用ruduce实现数组去重 let arr = [1,1,2,3,4,2,5,4]; let unique = arr.reduce(function (prev, item) { prev.indexOf(item) === -1 \u0026\u0026 prev.push(item); return prev; }, []); console.log(unique); // [1, 2, 3, 4, 5] 通过将空数组作为prev初始值 再通过indexOf判断数组中是否包含item，如果该元素不存在就返回-1， \u0026\u0026运算符第一条语句为true，则执行第二条，否则不执行 prev.push(item) 将item加入prev数组，最终返回数组prev 注意： indexOf()方法返回在数组中可以找到给定元素的第一个索引，如果该元素不存在，则返回-1。 关于\u0026\u0026运算符，第一条语句为true则执行第二条，否则不执行 ruduce的用法远不止这些，有兴趣的可以再了解以下~ 还有很多内置对象都是高阶函数，这里就不一一说明了，从上面的三个方法中，已经能很直观的感受到了函数接收函数作为参数，再返回值的过程，逼格很高也很好用 ","date":"2022-06-05","objectID":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/:1:3","tags":["前端","JS"],"title":"Javascript中的高阶函数","uri":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"},{"categories":["前端"],"content":"2. AOP面向切面编程 当我们需要使用一个公共函数，并且需要在这个函数执行前后添加自己的逻辑，通常我们的做法不能是直接修改这个函数，因为它是==公共函数==，这时候我们可以通过AOP的方法利用高阶函数和原型链的特点进行处理 把一些与业务无关的功能抽离出来，通过\"动态植入\"的方法，掺入到业务逻辑模块中。这样做的好处是保证业务逻辑模块的纯净和高内聚，其次可以方便的复用功能模块 需求：实现在函数==执行前==输出提示信息 这是一个函数 function say(who) { console.log(who + '：函数执行了'); } 实现在函数==执行前==输出提示信息 Function.prototype.before = function(callback) { return (...args) =\u003e { callback() this(...args) } } let whoSay = say.before(function() { console.log('你要被调用了'); }) whoSay('Milo') // 你要被调用了 // Milo：函数执行了 如果需要实现==后置通知==，只需要将callback()和this(…args)调换一下就可以了 Function.prototype.before = function(callback) { return (...args) =\u003e { this(...args) callback() } } // Milo：函数执行了 // 你要被调用了 实现的原理 在调用公共函数时，传入我们需要执行提前执行的函数，在内部函数执行前先调用该函数 ","date":"2022-06-05","objectID":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/:2:0","tags":["前端","JS"],"title":"Javascript中的高阶函数","uri":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"},{"categories":["前端"],"content":"3.偏函数 当一个函数有很多参数时，调用该函数就需要提供多个参数，如果可以减少参数的个数，就能简化该函数的调用，降低调用该函数的难度。 实现3个数求和 function sum(a, b, c){ return a + b + c; } console.log(sum(1, 2, 3)) // 6 在调用时我们需要传入3个参数，好像有些许麻烦，下面我们用偏函数的做法 创建一个新的partial函数，这个新函数可以固定住原函数的部分参数，从而减少调用时的输入的参数，让我们的调用更加简单 function sum(a, b, c) { return a + b + c } function partial(sum, c) { return function (a, b) { return sum(a, b, c) } } let partialSum = partial(sum, 3) console.log(partialSum(1,2))// 6 高阶函数除了可以接收函数作为参数外，还可以将函数作为结果返回，偏函数就是固定了函数的一个或多个参数，返回一个新的函数接收剩下的参数，以此来简化函数的调用。 Function.prototype.bind 函数就是一个偏函数的典型代表，它接受的第二个参数开始，为预先添加到绑定函数的参数列表中的参数 ","date":"2022-06-05","objectID":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/:3:0","tags":["前端","JS"],"title":"Javascript中的高阶函数","uri":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"},{"categories":["前端"],"content":"4. 函数柯里化 与偏函数不同，柯里化是把接收多个参数的函数转换成多个只接收一个参数的函数。 我们从一个简单的例子来认识函数柯里化 function add(a, b) { return a + b; } add(1, 2) // 3 普通做法 一次传入两个参数 // 假设有一个 curring 函数可以做到柯里化 function curring(){} curring(1)(2) // 我们通过这样的方式来接受参数，这样就实现了柯里化 接下来我们来看看利用柯里化来实现 function curring(x) { return return y =\u003e x + y } curring(1)(2) // =\u003e 3 ","date":"2022-06-05","objectID":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/:4:0","tags":["前端","JS"],"title":"Javascript中的高阶函数","uri":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"},{"categories":["前端"],"content":"4.1 函数柯里化的作用 要真正理解柯里化还是得看示例 4.1.1 参数复用 我们先看一段短短的代码，这段代码中，实现了输入输出个人信息的功能，通过myInfo函数将参数拼接返回，这实际上很简单，但是当有很多很多的用户信息时，需要一直传递着个人信息这个参数，这样显然是不合理的 function myInfo(inf, name, age) { return `${inf}：${name},${age}` } const myInfo1 = myInfo('个人信息', 'milo', '19') console.log(myInfo1); // 个人信息：milo,19 下面我们通过柯里化技术来解决 function myInfoCurry(inf) { return (name, age) =\u003e { return `${inf}：${name}${age}` } } let myInfoName = myInfoCurry('个人信息') const myInfo1 = myInfoName('milo', '19') const myInfo2 = myInfoName('Mmmy','19') console.log(myInfo2); // 个人信息：milo,19 console.log(myInfo1); // 个人信息：Mmmy,19 这个就是柯里化技术的作用之一了，参数复用，个人感觉还是很好用的 在上面代码的基础上，我们可以继续扩展我们的信息，就像这样，利用一个函数就可以实现多个功能 let myInfoHobby = myInfoCurry('爱好') const myInfo3 = myInfoHobby('看球赛','听歌') console.log(myInfo3); // 爱好：看球赛听歌 4.1.2 提前返回 这个特性是用来对浏览器的监听事件兼容性做一些判断并初始化，解决有些浏览器对addEventListener存在的兼容性问题，所以在使用之前做一次判断，之后就可以省略了 const whichEvent = (function () { if (window.addEventListener) { return function (ele, type, listener, useCapture) { ele.addEventListener(type, function (e) { listener.call(ele, e) }, useCapture) } } else if (window.attachEvent) { return function (ele, type, handler) { ele.attachEvent('on' + type, function (e) { handler.call(ele, e) }) } } })() 由于使用了立即执行函数，即使触发多次事件依旧只会触发一次if条件判断 4.1.3 延迟执行 下面我们通过一道例题来了解 编写一个add函数实现下面的功能 add(1)(2)(3) = 6 add(1, 2, 3)(4) = 10 add(1)(2)(3)(4)(5) = 15 function add(...args) { let inner = function () { args.push(...arguments); inner.toString = function () { return args.reduce((prev, cur) =\u003e { return prev + cur }) } return inner } return inner } console.log(add(1)(2)(3)); // f console.log(add(1)(2)(3).toString()); // 6 这段代码中涵盖的知识面很多，核心的部分在于inner.toString这里，利用了当返回一个函数时返回的是它的字符串形式，所以我们可以利用这个特性来自定义我们的返回值 ","date":"2022-06-05","objectID":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/:4:1","tags":["前端","JS"],"title":"Javascript中的高阶函数","uri":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"},{"categories":["算法"],"content":"LeetCode 0001.两数之和","date":"2022-06-05","objectID":"/leetcode-0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","tags":["leetcode","算法"],"title":"力扣 0001.两数之和","uri":"/leetcode-0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"categories":["算法"],"content":"1.两数之和 问题 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。 信息 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 示例 2： 输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3： 输入：nums = [3,3], target = 6 输出：[0,1] ","date":"2022-06-05","objectID":"/leetcode-0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/:1:0","tags":["leetcode","算法"],"title":"力扣 0001.两数之和","uri":"/leetcode-0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"categories":["算法"],"content":"法一：暴力解法 var twoSum = function(nums, target) { for(let i = 0,len = nums.length; i \u003c len; i++){ for(let j = i+1; j \u003c len; j++){ if((target - nums[i]) == nums[j]){ return [i,j]; } } } return []; }; 时间复杂度： O(N2)，其中 N是数组中的元素数量。对于每一个元素 x，我们可以 O(1) 地寻找 target - x。两个循环，所以是O(N2)。 空间复杂度： O(1) 简单粗暴,2遍for循环逐个遍历判断。 ","date":"2022-06-05","objectID":"/leetcode-0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/:2:0","tags":["leetcode","算法"],"title":"力扣 0001.两数之和","uri":"/leetcode-0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"categories":["算法"],"content":"法二：哈希表（官方答案） var twoSum = function(nums, target) { let map = new Map(); for(let i = 0; i \u003c nums.length; i++){ if(map.has(target - nums[i])){ return [map.get(target - nums[i]),i]; }else{ map.set(nums[i],i); } } return []; } 时间复杂度： O(N)，其中 N是数组中的元素数量。对于每一个元素 x，我们可以 O(1) 地寻找 target - x。 空间复杂度： O(N)，其中 N是数组中的元素数量。主要为哈希表的开销。 一遍for循环搞定,将数字存在哈希表的键值对中,并判断target-nums[i]的结果在哈希表键值对中是否存在,是则说明找到匹配数字。 我们遍历到数字a时,用target减去a,就会得到b,若b存在于哈希表中,我们就可以直接返回结果了。若b不存在,那么我们需要将a存入哈希表,好让后续遍历的数字使用。 ","date":"2022-06-05","objectID":"/leetcode-0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/:3:0","tags":["leetcode","算法"],"title":"力扣 0001.两数之和","uri":"/leetcode-0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"categories":["算法"],"content":"LeetCode 刷题预备知识","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"时间复杂度 ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:1:0","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"一. 大 O 表示法 关于复杂度的计算，我们采用的是 大 O 表示法 ，它用来描述算法性能和复杂程度 常见的表示 符号大O标记法 名称 O(1) 常数 O(log N) 对数 O(N) 线性 O(N log N) 对数多项式 O(N^2) 二次 O(2^N) 指数 O(N!) 阶乘 大 O 表示法一般考虑的是 CPU 占用时间，它可以粗略的了解代码运行的时间效率 例如 function test(num){ return ++num; } 我们调用这个函数一次，执行时间是 t ，我们再调用一次，执行时间还是 t，和传入的参数无关， test 函数的性能都一样，因此它的复杂度为 O(1) 当循环 n 次时，就是 O(n) ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:1:1","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"二. 时间复杂度 大 O 表示法表明的是该段代码执行时间随数据规模增大的变化趋势，它的特点是 只关注量级最大的时间复杂度 常见的时间复杂度量级 O(1) \u003c O(logn) \u003c O(n) \u003c O(n^2) 对于 O(2)、O(3) 这些，我们都叫做 O(1) 常数级 例如： 1. O(1) let i = 0; i += 1; // 每次执行代码只执行一次 O(1) 这段代码每次只执行一次，因此为 O(1) 2. O(n) for (let j = 0; j \u003c n; j++) { console.log(j); } 再上面这段代码中，我们每次都需要执行 n 次的 log ，因此我们可以把它看作 O(n) 同样的我们再来看一个 let i = 0; i += 1; for (let j = 0; j \u003c navigator; j++) { console.log(j); } 这种代码我们经常写，前面是我们刚刚计算的 O(1)，后面是 O(n) ，它们并行排列，时间复杂度相加，取最大的那个 因此它的时间复杂度同样是 O(n) 3. O(log(n)) while (i \u003c n) { console.log(i); i *= 2; } 对于 log(n) 的情况，在个时间复杂度是很好的，当然 O(1) 是最好的，但是在解题的时候，如果能优化到 log(n) 也是很不错的了 那它是如何计算的呢？ 我们可以看到，这里采用了 变量i来控制循环的终止，每次循环体中，都需要 2 * i 的操作 因此对于时间复杂度的计算 2^t = n 解得 t = log(n) 4. O(n^2) for (let i = 0; i \u003c n; i++) { for (let j = 0; j \u003c n; j++) { console.log(i); } } 对于这种嵌套排列，时间复杂度是 n^2 ，外面一层 n ，里面一层 n 乘一下就是 n^2，冒泡排序的时间复杂度就是 O(n^2) 关于时间复杂度就介绍这么多，其他的思路都差不多 ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:1:2","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"空间复杂度 空间复杂度表示的是：存储空间随数据规模的增长趋势，在 LeetCode 中最直接的反应就是内存消耗 例如 1. O(1) let i = 0; 在这里我们申请了单个变量的内存空间，为 O(1) 2. O(n) let arr = [] for(let i = 0;i \u003c n;i++) { arr.push(i) } 像这样的一个数组，并给它填满值，n 越大，它需要分配的空间就越多，它的空间复杂度就是 O(n) 3. O(n^2) int arr = [][] // 遍历赋值 声明一个二维数组，填满值，它的空间复杂度就是 O(n^2) ，你可以理解为一个矩阵，n*n 为 n^2 ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:2:0","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"📌 总结 复杂度计算按最高阶来计算 时间、空间复杂度描述的都是随数据规模的变化趋势 时间复杂度的重点在于循环嵌套 空间复杂度关注于内存 ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:2:1","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"链表基础知识 链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。 链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。 使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。 但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的存取往往要在不同的排列顺序中转换。 链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。 链表有很多种不同的类型：单向链表，双向链表以及循环链表。 ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:3:0","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"二叉树(BT,Binary Tree) ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:4:0","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"满二叉树(Full Binary Tree) 叶子结点只能出现在最下层，其他层所有结点均有左子树和右子树，且所有层都达到该层能拥有的最大结点树数。它是完全二叉树的一种特殊情况。 官方定义： 如果一颗二叉树的结点要么是叶子结点，要么他有两个子结点，这样的树就是满二叉树。 ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:4:1","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"完全二叉树(Complete Binary Tree) 叶子结点只能出现在最下层和次下层，其他层所有结点均有左子树和右子树，且最下层的叶子结点集中在树的左部。 官方定义： 一颗深度为h的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这颗二叉树称为完全二叉树。 ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:4:2","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"二叉搜索树(BST,Binary Search Tree) 每个结点的左子树中所有结点的值均小于该结点的值，右子树中所有结点的值均大于该结点。 ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:5:0","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"二分搜索基础知识 练习： 给定一个 n个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1: 输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 示例 2: 输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:6:0","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"法一： var search = function(nums, target) { //定义左指针和右指针分别指向开头和结尾 let left =0, right = nums.length - 1; //当left\u003c=right while(left \u003c= right){ //mid=(left+right)/2,之所以写成下面的形式是防止超出整型范围，防止溢出。 mid = Math.floor(left + (right - left)/2); //如果找到了，就输出 if(nums[mid] == target){ return mid; //如果目标比mid小，要把右半边舍弃 }else if(target \u003c nums[mid]){ right = mid - 1;//mid以及mid右边都舍弃 //如果目标比mid大，要把左半边舍弃 }else{ left = mid + 1;//mid以及mid左半边都舍弃 } } //没找到输出-1 return -1; }; ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:6:1","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"Set基础知识 //创建一个Set const numberSet = new Set(); //添加，set不会添加重复的值 numberSet.add(1); //删除,成功返回ture，失败返回false numberSet.delete(1); //判断set里是否有这个值，有返回ture，没有返回false numberSet.has(1); //输出set里有几个元素 numberSet.size //遍历set中所有元素 numberSet.forEach(number=\u003e console.log(number)) // console.log(numberSet); 练习： //1.判断下面这段代码最终输出的值 const set = new Set(); set.add(1); set.add(1); set.add(\"1\"); console.log(set) 输出：{1,\"1\"} ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:7:0","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"Map基础知识 //创建一个Map const person = new Map(); //添加,如果重复set，会覆盖原来的值 person.set(\"name\",\"milo\"); person.set(\"age\",18); person.set(\"hooby\",[\"看老毕和鱼皮的视频\",\"睡觉\",\"打CSGO\"]) //删除,成功返回ture，失败返回false person.delete(\"age\") //获取Map里的某个值 person.get(\"name\"); //判断set里是否有这个值，有返回ture，没有返回false person.has(\"age\"); //输出set里有几个元素 person.size //遍历set中所有元素 person.forEach(person=\u003e console.log(person)) // console.log(person); 练习： //2.创建一个map，并且添加如下数据：1:“北京”，2:“上海”，3:“杭州”，（0，1，2均为数字）。然后删除掉第一个元素。 const cities = new Map(); cities.set(1,\"北京\"); cities.set(2,\"上海\"); cities.set(3,\"杭州\"); console.log(cities); 输出：{1 =\u003e '北京', 2 =\u003e '上海', 3 =\u003e '杭州'} cities.delete(1); console.log(cities); 输出：{2 =\u003e '上海', 3 =\u003e '杭州'} ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:8:0","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"let和const let和const的区别： Let可以重新赋值，Const不可以。 var a = 1; console.log(a); var b = \"hello\"; console.log(b); //let可以重新赋值 let c = 10; c = c + 1 ; console.log(c); //const不可以重新赋值。会报错 const d = \"hello\"; d = d + \"world\"; console.log(d); var和let、const的区别： var成功重复声明变量，let和const不可以 var productPrice = 5.99; // line 1000 var productPrice = 9.99; //重复声明了变量 // line 5000 productPrice++; console.log(productPrice); 输出：10.99 var的作用域范围是函数作用域范围 var price =1; function setPrice() { price++; } setPrice(); console.log(price) 输出：2 function setPrice() { var price =1; //而把var写在函数里面，外面的console.log就识别不到var price++; } setPrice(); console.log(price) 输出：Uncaught ReferenceError: price is not defined var price =1; function setPrice() { var price = 10; console.log(price); //var是函数作用域，所以这个console能访问到外面的也能访问到函数里的price console.log(window.price); //访问全局的price } setPrice(); console.log(price) 输出：10 1 1 let和const的作用域范围是块作用域 for(var i = 0; i \u003c 5; i++) {} console.log(i) //var是函数作用域，而for是块不是函数，所以var的i出了for这个块作用域，依然占用这个变量名，局部变量造成了全局污染。 输出：5 for(let i = 0; i \u003c 5; i++) {} console.log(i) //let是块作用域，就解决了局部变量污染全局变量的问题。 输出：Uncaught ReferenceError: i is not defined const price = 10; if(price \u003c 59){ const deliverFee = 5; price += deliverFee; } console.log(price); 输出：Uncaught TypeError: Assignment to constant variable. 解释：const不能重新赋值 let price = 10; if(price \u003c 59){ const deliverFee = 5; price += deliverFee; } console.log(price); console.log(deliverFee); 输出：15 Uncaught TypeError: Assignment to constant variable. 解释：let可以重复赋值,const是块作用域，所以最后一个console无法访问deliverFee 练习： 第一题：用let或const改写这段使用var的旧程序 var subtotal = 19.9; var tax = 0.13; var total = subtotal * ( 1 + tax); console.log(total) 输出：22.487 const subtotal = 19.9; const tax = 0.13; const total = subtotal * ( 1 + tax); console.log(total) 输出：22.487 let subtotal = 19.9; let tax = 0.13; let total = subtotal * ( 1 + tax); console.log(total) 输出：22.487 练习： 第二题：用let或const改写这段使用var的旧程序（注意函数作用域和块作用域的区别，必要时需要改变部分代码） 如果成绩哎60分以上，则课程pass var point = 95; if(point \u003e= 60){ var pass = true; } console.log(pass); 输出：true let point = 95; let pass = false; if(point \u003e= 60){ pass = true; } console.log(pass); 输出：true let point = 95; if(point \u003e= 60){ pass = true; console.log(pass); } 输出：true ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:9:0","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["前端"],"content":"JS从入门到精通","date":"2022-06-03","objectID":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/","tags":["前端","JS"],"title":"JS从入门到精通","uri":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":" 引用 笔记链接 尚硅谷最新版JavaScript基础全套教程完整版(140集实战教学,JS从入门到精通) ","date":"2022-06-03","objectID":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:0:0","tags":["前端","JS"],"title":"JS从入门到精通","uri":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"目录 01_JS 简介 02_JS基础 03_JS运算 04_流程控制05-对象 06_函数 07_作用域 08_构造函数与原型对象 09_数组 10_call, apply 和 arguments 11_Date和Math 12_包装类和字符串 13_正则表达式 14_DOM 15_事件对象 16_滚轮事件与键盘事件 17_BOM 18_定时调用与延时调用 19_JSON 部分内容如下： JS简介 ","date":"2022-06-03","objectID":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:0:1","tags":["前端","JS"],"title":"JS从入门到精通","uri":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"1、什么是语言 计算机就是一个由人来控制的机器，人让它干嘛，它就得干嘛。 我们要学习的语言就是人和计算机交流的工具，人类通过语言来控制、操作计算机。 编程语言和我们说的中文、英文本质上没有区别，只是语法比较特殊。 语言的发展： 纸带机：机器语言 汇编语言：符号语言 现代语言：高级语言 ","date":"2022-06-03","objectID":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:1:0","tags":["前端","JS"],"title":"JS从入门到精通","uri":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"2、JS起源 JavaScript诞生于1995年，它的出现主要是用于处理网页中的前端验证。 所谓的前端验证，就是指检查用户输入的内容是否符合一定的规则。 比如：用户名的长度，密码的长度，邮箱的格式等。 ","date":"2022-06-03","objectID":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:2:0","tags":["前端","JS"],"title":"JS从入门到精通","uri":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"3、JS简史 JavaScript是由网景公司发明，起初命名为LiveScript，后来由于SUN公司的介入更名为了JavaScript。 1996年微软公司在其最新的IE3浏览器中引入了自己对JavaScript的实现JScript。 于是在市面上存在两个版本的JavaScript，一个网景公司的JavaScript和微软的JScript。 为了确保不同的浏览器上运行的JavaScript标准一致，所以几个公司共同定制了JS的标准名命名为ECMAScript。 时间表 年份 事件 1995年 网景公司开发了JavaScript 1996年 微软发布了和JavaScript兼容的JScript 1997年 ECMAScript第1版（ECMA-262） 1998年 ECMAScript第2版 1998年 DOM Level1的制定 1998年 新型语言DHTML登场 1999年 ECMAScript第3版 2000年 DOM Level2的制定 2002年 ISO/IEC16262：2002的确立 2004年 DOM Level3的制定 2005年 新型语言AJAX登场 2009年 ECMAScript第5版 2009年 新型语言HTML5登场 ","date":"2022-06-03","objectID":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:3:0","tags":["前端","JS"],"title":"JS从入门到精通","uri":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"4、实现 ECMAScript是一个标准，而这个标准需要由各个厂商去实现。 不同的浏览器厂商对该标准会有不同的实现。 浏览器 JavaScript实现方式 FireFox SpiderMonkey Internet Explorer JScript/Chakra Safari JavaScriptCore Chrome v8 Carakan Carakan 我们已经知道ECMAScript是JavaScript标准。所以一般情况下，这两个词我们认为是一个意思。 但是实际上JavaScript的含义却要更大一些。 一个完整的JavaScript实现应该由以下三个部分构成： ","date":"2022-06-03","objectID":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:4:0","tags":["前端","JS"],"title":"JS从入门到精通","uri":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"5、学习内容 我们已经知道了一个完整的JavaScript实现包含了三个部分：ECMAScript、DOM和BOM。 由此我们也知道了我们所要学习的内容就是这三部分。 ECMAScript DOM BOM ","date":"2022-06-03","objectID":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:5:0","tags":["前端","JS"],"title":"JS从入门到精通","uri":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"6、JS的特点 解释型语言 类似于C和Java的语法结构 动态语言 基于原型的面向对象 ","date":"2022-06-03","objectID":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:6:0","tags":["前端","JS"],"title":"JS从入门到精通","uri":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"7、HelloWorld ","date":"2022-06-03","objectID":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:7:0","tags":["前端","JS"],"title":"JS从入门到精通","uri":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"控制浏览器弹出一个警告框 alert(\"Hello World!\"); ","date":"2022-06-03","objectID":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:7:1","tags":["前端","JS"],"title":"JS从入门到精通","uri":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"让计算机在页面中输出一个内容 document.write(\"Hello World!\"); ","date":"2022-06-03","objectID":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:7:2","tags":["前端","JS"],"title":"JS从入门到精通","uri":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"向控制台输出一个内容 console.log(\"Hello World!\"); ","date":"2022-06-03","objectID":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:7:3","tags":["前端","JS"],"title":"JS从入门到精通","uri":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"JS从入门到精通","date":"2022-05-15","objectID":"/htmlcss/","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":" 引用 笔记链接 尚硅谷Web前端HTML5\u0026CSS3初学者零基础入门全套完整版学习笔记 ","date":"2022-05-15","objectID":"/htmlcss/:0:0","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"目录 01_前端简介.md 02_前端开发准备.md 03_字符实体与语义标签.md 04_CSS语法与选择器.md 05_样式继承与其他概念.md 06_盒模型.md 07_实战练习.md 08_盒模型补径场实战.md 09_浮动.md 10_高度塌陷与BFC.md 11 定位.md 12_字体.md 13_背景.md 14雪碧图与渐变.md 15_表格.md 16_过渡与动画.md 17_变形:平转与缩放.md 18_less 简介.md 19_弹性盒简介.md 20_像素与视口.md 21_媒体查询.md 部分内容如下： 前端简介 ","date":"2022-05-15","objectID":"/htmlcss/:0:1","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"1. 软件的分类 ","date":"2022-05-15","objectID":"/htmlcss/:1:0","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"1.1. 系统软件 Windows Linux macOS ","date":"2022-05-15","objectID":"/htmlcss/:1:1","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"1.2. 应用软件 Office QQ ","date":"2022-05-15","objectID":"/htmlcss/:1:2","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"1.3. 游戏软件 绝地求生 王者荣耀 ","date":"2022-05-15","objectID":"/htmlcss/:1:3","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"2. 客户端与服务器 通常情况下，现在的软件一般由两个部分组成： 客户端：用户通过客户端来使用软件。 服务器：服务器负责在远程处理业务逻辑。 ","date":"2022-05-15","objectID":"/htmlcss/:2:0","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"2.1. 服务器 服务器开发的语言： Java PHP C# Python Node.js …… ","date":"2022-05-15","objectID":"/htmlcss/:2:1","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"2.2. 客户端 客户端的形式 文字客户端：占老的方式，通过命令行来使用软件 图形化界面：通过点击拖动等来使用软件。Windows 中、macOS 中、Android、iOS 中的大部分应用。（C/S 架构） 网页：通过访问网页来使用软件。所有的网站都属于这个范畴。（B/S 架构） ","date":"2022-05-15","objectID":"/htmlcss/:2:2","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"3. 网页的特点 相较于传统的图形化界面，网页具有如下一些优点： 不需要安装 无需更新 跨平台 网页中使用的语言： HTML、CSS、JavaScript ","date":"2022-05-15","objectID":"/htmlcss/:3:0","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"4. 网页简史 蒂姆·伯纳斯·李爵士，万维网的发明人。 1991 年 8 月 6 日，世界上第一个服务器和第一个网站在欧洲核子研究中心上线。 第一个网站：http://info.cern.ch/hypertext/WWW/TheProject.html ","date":"2022-05-15","objectID":"/htmlcss/:4:0","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"5. 浏览器和网页 有了浏览器我们只需要一个网址便可以访问任何的网站。 而浏览器中所显示的内容正是我们所说的网页。 网页原本的样子： ... \u003c!--无障碍占位--\u003e \u003cdiv id=\"J_accessibility\"\u003e\u003c/div\u003e \u003c!--顶通占位 --\u003e \u003cdiv id=\"J_promotional-top\"\u003e\u003c/div\u003e \u003cdiv id=\"shortcut\"\u003e \u003cdiv class=\"w\"\u003e \u003cul class=\"fl\" clstag=\"h|keycount|head|topbar_01\"\u003e \u003cli class=\"dropdown\" id=\"ttbar-mycity\"\u003e\u003c/li\u003e \u003c/ul\u003e \u003cul class=\"fr\"\u003e \u003cli class=\"fore1 dropdown\" id=\"ttbar-login\" clstag=\"h|keycount|head|topbar_02\" \u003e \u003ca href=\"//passport.jd.com/uc/login?ReturnUrl=https%3A%2F%2Fwww.jd.com%2F\" class=\"link-login\" \u003e你好，请登录\u003c/a \u003e\u0026nbsp;\u0026nbsp;\u003ca href=\"//reg.jd.com/reg/person?ReturnUrl=https%3A//www.jd.com/\" class=\"link-regist style-red\" \u003e免费注册\u003c/a \u003e \u003c/li\u003e \u003cli class=\"spacer\"\u003e\u003c/li\u003e \u003cli class=\"fore2\" clstag=\"h|keycount|head|topbar_03\"\u003e \u003cdiv class=\"dt\"\u003e \u003ca target=\"_blank\" href=\"//order.jd.com/center/list.action\" \u003e我的订单\u003c/a \u003e \u003c/div\u003e \u003c/li\u003e \u003cli class=\"spacer\"\u003e\u003c/li\u003e \u003cli class=\"fore3 dropdown\" id=\"ttbar-myjd\" clstag=\"h|keycount|head|topbar_04\" \u003e \u003cdiv class=\"dt cw-icon\"\u003e \u003ca target=\"_blank\" href=\"//home.jd.com/\"\u003e我的京东\u003c/a \u003e\u003ci class=\"iconfont\"\u003e\u0026#xe610;\u003c/i\u003e\u003ci class=\"ci-right\"\u003e\u003cs\u003e◇\u003c/s\u003e\u003c/i\u003e \u003c/div\u003e \u003cdiv class=\"dd dropdown-layer\"\u003e\u003c/div\u003e \u003c/li\u003e \u003cli class=\"spacer\"\u003e\u003c/li\u003e \u003cli class=\"fore4\" clstag=\"h|keycount|head|topbar_05\"\u003e \u003cdiv class=\"dt\"\u003e \u003ca target=\"_blank\" href=\"//vip.jd.com/\"\u003e京东会员\u003c/a\u003e \u003c/div\u003e \u003c/li\u003e \u003cli class=\"spacer\"\u003e\u003c/li\u003e \u003cli class=\"fore5\" clstag=\"h|keycount|head|topbar_06\"\u003e \u003cdiv class=\"dt\"\u003e\u003ca target=\"_blank\" href=\"//b.jd.com/\"\u003e企业采购\u003c/a\u003e\u003c/div\u003e \u003c/li\u003e \u003cli class=\"spacer\"\u003e\u003c/li\u003e \u003cli class=\"fore8 dropdown\" id=\"ttbar-serv\" clstag=\"h|keycount|head|topbar_07\" \u003e \u003cdiv class=\"dt cw-icon\"\u003e 客户服务\u003ci class=\"iconfont\"\u003e\u0026#xe610;\u003c/i \u003e\u003ci class=\"ci-right\"\u003e\u003cs\u003e◇\u003c/s\u003e\u003c/i\u003e \u003c/div\u003e \u003cdiv class=\"dd dropdown-layer\"\u003e\u003c/div\u003e \u003c/li\u003e \u003cli class=\"spacer\"\u003e\u003c/li\u003e \u003cli class=\"fore9 dropdown\" id=\"ttbar-navs\" clstag=\"h|keycount|head|topbar_08\" \u003e \u003cdiv class=\"dt cw-icon\"\u003e 网站导航\u003ci class=\"iconfont\"\u003e\u0026#xe610;\u003c/i \u003e\u003ci class=\"ci-right\"\u003e\u003cs\u003e◇\u003c/s\u003e\u003c/i\u003e \u003c/div\u003e \u003cdiv class=\"dd dropdown-layer\"\u003e\u003c/div\u003e \u003c/li\u003e \u003cli class=\"spacer\"\u003e\u003c/li\u003e \u003cli class=\"fore10 mobile\" id=\"J_mobile\" clstag=\"h|keycount|head|topbar_09\" \u003e \u003cdiv class=\"dt mobile_txt\"\u003e手机京东\u003c/div\u003e \u003cdiv class=\"mobile_static\"\u003e \u003cdiv class=\"mobile_static_qrcode\"\u003e\u003c/div\u003e \u003c/div\u003e \u003cdiv id=\"J_mobile_pop\" class=\"mod_loading mobile_pop\"\u003e\u003c/div\u003e \u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003c/div\u003e ... 浏览器渲染后的样子： 前端工程师负责编写网页的源代码。 浏览器负责将网页渲染成我们想要的样子。 ","date":"2022-05-15","objectID":"/htmlcss/:5:0","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"5.1. 浏览器的问题 市面上存在有很多不同的浏览器。 在万维网的初期，网页编写并没有标准。 于是就出现了这种情况： ","date":"2022-05-15","objectID":"/htmlcss/:5:1","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"5.2. W3C 的建立 伯纳斯李 1994 年建立万维网联盟（W3C） W3C 的出现为了制订网页开发的标准，以使同一个网页在不同的浏览器中有相同的效果。 所以，我们需要制订我们编写的网页都需要遵循 W3C 的规范！ ","date":"2022-05-15","objectID":"/htmlcss/:5:2","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"5.3. 网页的结构思想 根据 W3C 标准，一个网页主要由三部分组成：结构、表现还有行为。 结构、表现、行为 结构（骨架）：HTML 用于描述页面的结构 表现（皮肤）：CSS 用于控制页面中元素的样式 行为（交互）：JavaScript 用于响应用户操作 ","date":"2022-05-15","objectID":"/htmlcss/:5:3","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"6. 网页的基本结构 ","date":"2022-05-15","objectID":"/htmlcss/:6:0","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"6.1. 迭代 网页的版本 HTML4 XHTML2.0 HTML5 ","date":"2022-05-15","objectID":"/htmlcss/:6:1","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"6.2. 文档声明（doctype） 文档声明用来告诉浏览器当前网页的版本 \u003c!-- html5的文档声明 --\u003e \u003c!DOCTYPE html\u003e \u003c!-- 或者 --\u003e \u003c!DOCTYPE html\u003e ","date":"2022-05-15","objectID":"/htmlcss/:6:2","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"6.3. 字符编码 所有的数据在计算机中存储时都是以二进制形式存储的，文字也不例外。 所以一段文字在存储到内存中时，都需要转换为二进制编码当我们读取这段文字时，计算机会将编码转换为字符，供我们阅读 编码 将字符转换为二进制码的过程称为编码 解码 将二进制码转换为字符的过程称为解码 字符集（charset） 编码和解码所采用的规则称为字符集（相当于密码本） 乱码 如果编码和解码所采用的字符集不同就会出现乱码问题。 可以通过 meta 标签来设置网页的字符集，避免乱码问题 \u003cmeta charset=\"utf-8\" /\u003e ","date":"2022-05-15","objectID":"/htmlcss/:6:3","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"6.4. 常见的字符集 ASCII ASCII(American Standard Code for Information Interchange)：美国信息交换标准代码 在所有字符集中，最知名的可能要数被称为 ASCII 的8 位字符了。美国信息交换标准代码是由美国国家标准学会(American National Standard Institute , ANSI )制定的，是一种标准的单字节字符编码方案，用于基于文本的数据。它最初是美国国家标准，供不同计算机在相互通信时用作共同遵守的西文字符编码标准，后来它被国际标准化组织（International Organization for Standardization, ISO）定为国际标准，称为 ISO 646 标准。适用于所有拉丁文字字母 ASCII 码使用指定的 7 位或 8 位二进制数组合来表示 128 或 256 种可能的字符。标准 ASCII 码也叫基础 ASCII 码，使用 7 位二进制数（剩下的 1 位二进制为 0）来表示所有的大写和小写字母，数字 0 到 9、标点符号，以及在美式英语中使用的特殊控制字符 ASCII 码表：Ascii Table - ASCII character codes and html, octal, hex and decimal chart conversion ISO-8859-1 ISO-8859-1 编码是单字节编码，向下兼容 ASCII，其编码范围是 0x00-0xFF，0x00-0x7F 之间完全和 ASCII 一致，0x80-0x9F 之间是控制字符，0xA0-0xFF 之间是文字符号。 ISO 码表：HTML ISO-8859-1 参考手册 GB2312 GB2312（信息交换用汉字编码字符集）是由中国国家标准总局 1980 年发布。基本集共收入汉字 6763 个和非汉字图形字符 682 个。GB 2312 的出现，基本满足了汉字的计算机处理需要，它所收录的汉字已经覆盖中国大陆 99.75%的使用频率。 GBK GBK（即“国标”、“扩展”汉语拼音的第一个字母），汉字编码字符集。2000 年已被 GB18030-2000 国家强制标准替代。 2005 年 GB18030-2005 发布，替代了 GB18030-2000。 GBK 使用了双字节编码方案，其编码范围从 8140 至 FEFE（剔除 xx7F），共 23940 个码位，共收录了 21003 个汉字，完全兼容 GB2312-80 标准，支持国际标准 ISO/IEC10646-1 和国家标准 GB13000-1 中的全部中日韩汉字，并包含了 BIG5 编码中的所有汉字。 Big5 Big5，又称为大五码或五大码，是使用繁体中文（正体中文）社区中最常用的电脑汉字字符集标准，共收录 13,060 个汉字。 Big5 虽普及于台湾、香港与澳门等繁体中文通行区，但长期以来并非当地的国家/地区标准或官方标准，而只是业界标准。倚天中文系统、Windows 繁体中文版等主要系统的字符集都是以 Big5 为基准，但厂商又各自增加不同的造字与造字区，派生成多种不同版本。 UTF-8 UTF-8（8 位元，Universal Character Set/Unicode Transformation Format）是针对 Unicode 的一种可变长度字符编码，也叫万国码、统一码。它可以用来表示 Unicode 标准中的任何字符，而且其编码中的第一个字节仍与 ASCII 相容，使得原来处理 ASCII 字符的软件无须或只进行少部分修改后，便可继续使用。 UTF-16 UTF-16 是 Unicode 的其中一个使用方式。UTF-16 比起 UTF-8，好处在于大部分字符都以固定长度的字节（2 字节）储存，但 UTF-16 却无法兼容于 ASCII 编码。 Unicode Unicode 只是一组字符设定或者说是从数字和字符之间的逻辑映射的概念编码，但是它并没有指定代码点如何在计算机上存储。UCS4、UTF-8、UTF-16（UTF 后的数字代表编码的最小单位，如 UTF-8 表示最小单位 1 字节，所以它可以使用 1、2、3 字节等进行编码，UTF-16 表示最小单位 2 字节，所以它可以使用 2、4 字节进行编码）都是 Unicode 的编码方案。UTF-8 因可以兼容 ASCII 而被广泛使用。 如果把各种文字编码形容为各地的方言，那么 Unicode 就是世界各国合作开发的一种语言。 ","date":"2022-05-15","objectID":"/htmlcss/:6:4","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"6.5. HTML5 的基本结构 \u003c!-- 文档声明，声明当前网页的版本 --\u003e \u003c!DOCTYPE html\u003e \u003c!-- html的根标签（元素），网页中的所有内容都要写根元素的里边 --\u003e \u003chtml\u003e \u003c!-- head是网页的头部，head中的内容不会在网页中直接出现，主要用来帮助浏览器或搜索引擎来解析网页 --\u003e \u003chead\u003e \u003c!-- meta标签用来设置网页的元数据，这里meta用来设置网页的字符集，避免乱码问题 --\u003e \u003cmeta charset=\"utf-8\" /\u003e \u003c!-- title中的内容会显示在浏览器的标题栏，搜索引擎会主要根据title中的内容来判断网页的主要内容 --\u003e \u003ctitle\u003e网页的标题\u003c/title\u003e \u003c/head\u003e \u003c!-- body是htm1的子元素，表示网页的主体，网页中所有的可见内容都应该写在body里 --\u003e \u003cbody\u003e \u003c!-- h1网页的一级标题 --\u003e \u003ch1\u003e网页的大标题\u003c/h1\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-05-15","objectID":"/htmlcss/:6:5","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"前端学习计划","date":"2022-05-01","objectID":"/frontend/","tags":["前端","HTML","CSS","JS","Git","ES6","Ajax","axios","Promise","React","Webpack"],"title":"前端学习计划","uri":"/frontend/"},{"categories":["前端"],"content":"HTML、CSS（尚硅谷超哥） 视频链接：尚硅谷Web前端零基础入门HTML5+CSS3基础教程丨初学者从入门到精通 相关学习资料: 1.块级元素和行内元素：https://www.cnblogs.com/yc8930143/p/7237456.html 2.盒子模型： https://segmentfault.com/a/1190000013069516 3.CSS选择器： https://segmentfault.com/a/1190000013424772 ","date":"2022-05-01","objectID":"/frontend/:0:1","tags":["前端","HTML","CSS","JS","Git","ES6","Ajax","axios","Promise","React","Webpack"],"title":"前端学习计划","uri":"/frontend/"},{"categories":["前端"],"content":"JavaScript（尚硅谷超哥） 视频链接：尚硅谷JavaScript基础\u0026实战丨JS入门到精通全套完整版 相关学习资料: 1.现代JavaScript教程：https://zh.javascript.info/ ","date":"2022-05-01","objectID":"/frontend/:0:2","tags":["前端","HTML","CSS","JS","Git","ES6","Ajax","axios","Promise","React","Webpack"],"title":"前端学习计划","uri":"/frontend/"},{"categories":["前端"],"content":"JavaScript进阶高级部分（尚硅谷） 视频链接：https://www.bilibili.com/video/BV14s411E7qf ","date":"2022-05-01","objectID":"/frontend/:0:3","tags":["前端","HTML","CSS","JS","Git","ES6","Ajax","axios","Promise","React","Webpack"],"title":"前端学习计划","uri":"/frontend/"},{"categories":["前端"],"content":"ES6（尚硅谷） 视频链接：https://www.bilibili.com/video/BV1uK411H7on ","date":"2022-05-01","objectID":"/frontend/:0:4","tags":["前端","HTML","CSS","JS","Git","ES6","Ajax","axios","Promise","React","Webpack"],"title":"前端学习计划","uri":"/frontend/"},{"categories":["前端"],"content":"3小时Ajax入门到精通（尚硅谷） 视频链接：https://www.bilibili.com/video/BV1WC4y1b78y ","date":"2022-05-01","objectID":"/frontend/:0:5","tags":["前端","HTML","CSS","JS","Git","ES6","Ajax","axios","Promise","React","Webpack"],"title":"前端学习计划","uri":"/frontend/"},{"categories":["前端"],"content":"axios入门与源码解析（尚硅谷） 视频链接：尚硅谷Web前端axios入门与源码解析 ","date":"2022-05-01","objectID":"/frontend/:0:6","tags":["前端","HTML","CSS","JS","Git","ES6","Ajax","axios","Promise","React","Webpack"],"title":"前端学习计划","uri":"/frontend/"},{"categories":["前端"],"content":"Promise（尚硅谷） 视频链接：尚硅谷Web前端Promise教程从入门到精通 ","date":"2022-05-01","objectID":"/frontend/:0:7","tags":["前端","HTML","CSS","JS","Git","ES6","Ajax","axios","Promise","React","Webpack"],"title":"前端学习计划","uri":"/frontend/"},{"categories":["前端"],"content":"React（尚硅谷天禹） 视频链接：尚硅谷React技术全家桶全套完整版（零基础入门到精通/男神天禹老师亲授） ","date":"2022-05-01","objectID":"/frontend/:0:8","tags":["前端","HTML","CSS","JS","Git","ES6","Ajax","axios","Promise","React","Webpack"],"title":"前端学习计划","uri":"/frontend/"},{"categories":["前端"],"content":"Node.JS（尚硅谷） 视频链接：https://www.bilibili.com/video/BV1bs411E7pD ","date":"2022-05-01","objectID":"/frontend/:0:9","tags":["前端","HTML","CSS","JS","Git","ES6","Ajax","axios","Promise","React","Webpack"],"title":"前端学习计划","uri":"/frontend/"},{"categories":["前端"],"content":"Webpack（尚硅谷） 视频链接：https://www.bilibili.com/video/BV1e7411j7T5 ","date":"2022-05-01","objectID":"/frontend/:0:10","tags":["前端","HTML","CSS","JS","Git","ES6","Ajax","axios","Promise","React","Webpack"],"title":"前端学习计划","uri":"/frontend/"},{"categories":["前端"],"content":"Git（尚硅谷） 视频链接：https://www.bilibili.com/video/BV15J411973T ","date":"2022-05-01","objectID":"/frontend/:0:11","tags":["前端","HTML","CSS","JS","Git","ES6","Ajax","axios","Promise","React","Webpack"],"title":"前端学习计划","uri":"/frontend/"},{"categories":null,"content":"Milo ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"我 本科：上海工程技术大学 计算机科学与技术 硕士：上海工程技术大学 电子信息 研究方向-知识图谱、推荐系统 ","date":"0001-01-01","objectID":"/about/:0:1","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"Tags 爱打篮球、踢足球 喜欢吉他弹唱 前端开发 喜欢玩CSGO 不抽烟不喝酒不蹦迪 ","date":"0001-01-01","objectID":"/about/:0:2","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"技术评级 英语四六级 HTML\u0026CSS 入门 Less 业余 Javascript 入门 React 入门 Python 入门 Java 业余 保持谦逊 保持对新技术的不断探索 保持积极向上的心态 ","date":"0001-01-01","objectID":"/about/:0:3","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"各位留个友链格式如下： name = Milo url = https://milo980412.github.io logo = https://milo980412.github.io/images/aniya.webp word = 保持谦逊，不断学习 Yulin Lewis \"不想当写手的码农不是好咸鱼_(xз」∠)_\" 李立超 \"前端我超哥!\" 小丞的前端日记 \"无比热爱，来日方长!\" zsqw123 \"岳女士 yyds\" 东南dnf \"周顺大弟子\" dextercai \"Helo.😄\" ","date":"0001-01-01","objectID":"/friends/:0:0","tags":null,"title":"友链墙","uri":"/friends/"},{"categories":null,"content":"感谢投喂～💗 支付宝 微信 ","date":"0001-01-01","objectID":"/donate/:0:1","tags":null,"title":"赞赏","uri":"/donate/"}]