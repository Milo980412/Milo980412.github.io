[{"categories":["工具"],"content":"MacOS如何生成目录树？","date":"2022-07-07","objectID":"/macos%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E7%9B%AE%E5%BD%95%E6%A0%91/","tags":["homebrew","markdown","目录树"],"title":"MacOS如何生成目录树？","uri":"/macos%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E7%9B%AE%E5%BD%95%E6%A0%91/"},{"categories":["工具"],"content":"MacOS如何生成目录树？ 在一个项目的 README 中，我们往往会想把项目的目录结构进行一下介绍或者注释，这样方便其他人接手项目时快速熟悉，同时也方便自己回忆起项目结构。那么效果比较好的呈现方式自然就是目录树，如何快速生成项目的目录树呢？ 我们第一反应是 tree 命令，可 MacOS 并不自带 tree 命令，所以需要手动安装！ ","date":"2022-07-07","objectID":"/macos%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E7%9B%AE%E5%BD%95%E6%A0%91/:0:0","tags":["homebrew","markdown","目录树"],"title":"MacOS如何生成目录树？","uri":"/macos%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E7%9B%AE%E5%BD%95%E6%A0%91/"},{"categories":["工具"],"content":"HomeBrew 安装 tree 用 homebrew 安装最方便，没有 brew 的 mac 用户，或者下载失败的，可以看我之前那篇文章 MacOS下HomBrew安装教程 安装好 homebrew 后，直接安装 tree brew install tree ","date":"2022-07-07","objectID":"/macos%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E7%9B%AE%E5%BD%95%E6%A0%91/:1:0","tags":["homebrew","markdown","目录树"],"title":"MacOS如何生成目录树？","uri":"/macos%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E7%9B%AE%E5%BD%95%E6%A0%91/"},{"categories":["工具"],"content":"使用 tree 我们先 cd 到要生存目录树的文件夹，然后使用 tree ","date":"2022-07-07","objectID":"/macos%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E7%9B%AE%E5%BD%95%E6%A0%91/:2:0","tags":["homebrew","markdown","目录树"],"title":"MacOS如何生成目录树？","uri":"/macos%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E7%9B%AE%E5%BD%95%E6%A0%91/"},{"categories":["工具"],"content":"输出指定层级的目录树 直接使用 tree 命令，它会把所有层级都输出，但如果我们只要输出 2 个层级就可以了，那么可以这样使用 // -L level 表示只会遍历到指定层级 tree -L 2 ","date":"2022-07-07","objectID":"/macos%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E7%9B%AE%E5%BD%95%E6%A0%91/:3:0","tags":["homebrew","markdown","目录树"],"title":"MacOS如何生成目录树？","uri":"/macos%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E7%9B%AE%E5%BD%95%E6%A0%91/"},{"categories":["工具"],"content":"忽略某些文件夹输出目录树 前端项目基本都会有这个问题，就是会把 node_modules 也输出成目录树，一下子目录树会无比巨大，而且一般我们也并不需要输出这个文件夹下的内容，那么可以这样使用 // -I pattern 表示不会将匹配到的文件/文件夹输出，即类似 ignore 的功能 tree -I node_modules 其他命令，可以通过 tree --help 来查看需要的参数 ","date":"2022-07-07","objectID":"/macos%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E7%9B%AE%E5%BD%95%E6%A0%91/:4:0","tags":["homebrew","markdown","目录树"],"title":"MacOS如何生成目录树？","uri":"/macos%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E7%9B%AE%E5%BD%95%E6%A0%91/"},{"categories":["工具"],"content":"MacOS 使用 npm 安装 SASS 与使用教程","date":"2022-07-06","objectID":"/macos-%E4%BD%BF%E7%94%A8-npm-%E5%AE%89%E8%A3%85-sass-%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","tags":["CSS","SASS","npm"],"title":"MacOS 使用 npm 安装 SASS 与使用教程","uri":"/macos-%E4%BD%BF%E7%94%A8-npm-%E5%AE%89%E8%A3%85-sass-%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"MacOS 使用 npm 安装 SASS 与使用教程 这里 Milo 使用 npm 来安装 sass 并使用，比较方便快捷 ","date":"2022-07-06","objectID":"/macos-%E4%BD%BF%E7%94%A8-npm-%E5%AE%89%E8%A3%85-sass-%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:0:0","tags":["CSS","SASS","npm"],"title":"MacOS 使用 npm 安装 SASS 与使用教程","uri":"/macos-%E4%BD%BF%E7%94%A8-npm-%E5%AE%89%E8%A3%85-sass-%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"1 npm 的安装 首先确保你有node.js，才能使用npm npm是Node.js (opens new window)默认的软件包管理系统，安装完node后，会默认安装好npm 我用的homebrew在我的Mac上安装的node brew install node 然后用命令查看node版本和npm版本 node -v //v18.2.0 npm -v //8.9.0 使用命令npm install -g全局安装npm，会默认更新最新版本 ","date":"2022-07-06","objectID":"/macos-%E4%BD%BF%E7%94%A8-npm-%E5%AE%89%E8%A3%85-sass-%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:1:0","tags":["CSS","SASS","npm"],"title":"MacOS 使用 npm 安装 SASS 与使用教程","uri":"/macos-%E4%BD%BF%E7%94%A8-npm-%E5%AE%89%E8%A3%85-sass-%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"2 sass 的安装 使用命令 npm i npm -g 全局安装 npm，会默认更新最新版本 npm install -g sass 然后用命令查看sass版本 sass --version //1.53.0 compiled with dart2js 2.17.3 ","date":"2022-07-06","objectID":"/macos-%E4%BD%BF%E7%94%A8-npm-%E5%AE%89%E8%A3%85-sass-%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:0","tags":["CSS","SASS","npm"],"title":"MacOS 使用 npm 安装 SASS 与使用教程","uri":"/macos-%E4%BD%BF%E7%94%A8-npm-%E5%AE%89%E8%A3%85-sass-%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"3 sass 的使用方法 首先要创建2个文件夹，比如sass、css 在终端启动监听命令，这里的sass:css 就是你两个文件夹的名字 sass --watch sass:css 在sass文件夹创建.scss文件，在.scss文件写入css，另一个css文件夹就会自动出现.css文件 ","date":"2022-07-06","objectID":"/macos-%E4%BD%BF%E7%94%A8-npm-%E5%AE%89%E8%A3%85-sass-%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:3:0","tags":["CSS","SASS","npm"],"title":"MacOS 使用 npm 安装 SASS 与使用教程","uri":"/macos-%E4%BD%BF%E7%94%A8-npm-%E5%AE%89%E8%A3%85-sass-%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"4 sass 教程 详细内容可看 Sass中文网 ","date":"2022-07-06","objectID":"/macos-%E4%BD%BF%E7%94%A8-npm-%E5%AE%89%E8%A3%85-sass-%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:4:0","tags":["CSS","SASS","npm"],"title":"MacOS 使用 npm 安装 SASS 与使用教程","uri":"/macos-%E4%BD%BF%E7%94%A8-npm-%E5%AE%89%E8%A3%85-sass-%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"MacOS HomBrew 安装教程 完美解决方案","date":"2022-07-04","objectID":"/macos%E4%B8%8Bhombrew%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/","tags":["homebrew"],"title":"MacOS下HomBrew安装教程","uri":"/macos%E4%B8%8Bhombrew%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"MacOS HomBrew 安装教程 完美解决方案 ","date":"2022-07-04","objectID":"/macos%E4%B8%8Bhombrew%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:0:0","tags":["homebrew"],"title":"MacOS下HomBrew安装教程","uri":"/macos%E4%B8%8Bhombrew%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"自动脚本(全部国内地址)（复制下面一句脚本到终端中粘贴回车) 苹果电脑 常规安装脚本（几分钟安装完成）： /bin/zsh -c \"$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)\" MacOS 打开终端 复制粘贴 5个序号随便选，我之前从第一个试到5阿里才成功 苹果电脑 卸载脚本： /bin/zsh -c \"$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/HomebrewUninstall.sh)\" 常见错误去下方地址查看 https://gitee.com/cunkai/HomebrewCN/blob/master/error.md ","date":"2022-07-04","objectID":"/macos%E4%B8%8Bhombrew%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:1:0","tags":["homebrew"],"title":"MacOS下HomBrew安装教程","uri":"/macos%E4%B8%8Bhombrew%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"React从入门到精通","date":"2022-06-15","objectID":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/","tags":["前端","React"],"title":"React从入门到精通","uri":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":" 📢 大家好 ，我是Milo同学，最近在学习 React，是我学习的第一个框架 先附上React官网 ，有很多问题都要通过查询官方文档来解决，要学会查文档。 ","date":"2022-06-15","objectID":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:0:0","tags":["前端","React"],"title":"React从入门到精通","uri":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"介绍 此项目为Milo在学习React的过程中记录的 笔记 和 源码 ，视频看的是B站尚硅谷天禹老师的React全家桶，笔记参考了小丞大佬的学习笔记，综合整理了笔记、源码code和相关面试题，面试题后面会持续更新，也会单独建立一个项目。 ","date":"2022-06-15","objectID":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:1:0","tags":["前端","React"],"title":"React从入门到精通","uri":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"其他地址 Github：https://github.com/Milo980412/NOTE_REACT 语雀：https://www.yuque.com/u26476221/il2ap7 Milo前端日记：React入门学习 ","date":"2022-06-15","objectID":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:2:0","tags":["前端","React"],"title":"React从入门到精通","uri":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"目录 React 基础 01_基础知识以及 jsx语法 hello_react 虚拟DOM的两种创建方式 jsx语法规则 jsx的小练习 02_面向组件编程 react中定义组件 组件实例三大属性1_state 组件实例三大属性2_props 组件实例三大属性3_refs react中的事件处理 react中收集表单数据 高阶函数_函数柯里化 03_组件的生命周期 04_DOM的Diffing算法 React 脚手架 05_初始化脚手架 06_TodoList 案例 07_脚手架配置代理 08_Github 搜索案例 09_消息订阅发布 10_React 路由 11_React 路由传参数 12_React 路由跳转 13_antd 的基本使用 14_redux 基本使用 15_React-Redux 基本使用 16_数据共享 17_React 扩展 React-Hooks React核心 – React-Hooks ","date":"2022-06-15","objectID":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:3:0","tags":["前端","React"],"title":"React从入门到精通","uri":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"参考 笔记来源 尚硅谷React技术全家桶全套完整版（零基础入门到精通/男神天禹） 笔记参考 小丞的前端日记 ","date":"2022-06-15","objectID":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:4:0","tags":["前端","React"],"title":"React从入门到精通","uri":"/react%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["技术"],"content":"解决一台电脑实现多个Github账号发布博客","date":"2022-06-10","objectID":"/mac%E5%A4%9A%E4%B8%AAgithub%E8%B4%A6%E5%8F%B7%E5%8F%91%E5%B8%83%E5%A4%9A%E4%B8%AA%E5%8D%9A%E5%AE%A2/","tags":["Github Pages","Git","Hugo","Vuepress","博客"],"title":"解决一台电脑实现多个Github账号发布博客","uri":"/mac%E5%A4%9A%E4%B8%AAgithub%E8%B4%A6%E5%8F%B7%E5%8F%91%E5%B8%83%E5%A4%9A%E4%B8%AA%E5%8D%9A%E5%AE%A2/"},{"categories":["技术"],"content":"解决一台电脑实现多个Github账号发布博客 Milo之前在自己的GitHub Pages 搭建 Hugo 静态博客网站，Hugo写博客挺好，但是放一些比较多的学习笔记、文档什么的很麻烦，接触到vuepress，非常适合做我的在线文档和笔记记录的地方。 于是Milo想再申请一个账号搭建一个新的vuepress博客，我想在同一台mac上完成两个博客的更新，但因为每次都要重新删github在mac上存留的密码，十分麻烦，所以今天一次性解决它，顺便记录下来分享给大家。 ","date":"2022-06-10","objectID":"/mac%E5%A4%9A%E4%B8%AAgithub%E8%B4%A6%E5%8F%B7%E5%8F%91%E5%B8%83%E5%A4%9A%E4%B8%AA%E5%8D%9A%E5%AE%A2/:1:0","tags":["Github Pages","Git","Hugo","Vuepress","博客"],"title":"解决一台电脑实现多个Github账号发布博客","uri":"/mac%E5%A4%9A%E4%B8%AAgithub%E8%B4%A6%E5%8F%B7%E5%8F%91%E5%B8%83%E5%A4%9A%E4%B8%AA%E5%8D%9A%E5%AE%A2/"},{"categories":["技术"],"content":"Hugo/Vuepress + Github Pages 相信很多同学都用Hugo/Vuepress + Github Pages搭建个人博客，其实用什么都行，Hexo、Halo等 ","date":"2022-06-10","objectID":"/mac%E5%A4%9A%E4%B8%AAgithub%E8%B4%A6%E5%8F%B7%E5%8F%91%E5%B8%83%E5%A4%9A%E4%B8%AA%E5%8D%9A%E5%AE%A2/:2:0","tags":["Github Pages","Git","Hugo","Vuepress","博客"],"title":"解决一台电脑实现多个Github账号发布博客","uri":"/mac%E5%A4%9A%E4%B8%AAgithub%E8%B4%A6%E5%8F%B7%E5%8F%91%E5%B8%83%E5%A4%9A%E4%B8%AA%E5%8D%9A%E5%AE%A2/"},{"categories":["技术"],"content":"关于Github Pages GitHub Pages 是由 GitHub 官方提供的一种免费的静态站点托管服务，可以在 GitHub 仓库里托管和发布自己的静态网站页面；Hexo 是一个快速、简洁且高效的静态博客框架，它基于 Node.js 运行，可以将我们撰写的 Markdown 文档解析渲染成静态的 HTML 网页 ","date":"2022-06-10","objectID":"/mac%E5%A4%9A%E4%B8%AAgithub%E8%B4%A6%E5%8F%B7%E5%8F%91%E5%B8%83%E5%A4%9A%E4%B8%AA%E5%8D%9A%E5%AE%A2/:2:1","tags":["Github Pages","Git","Hugo","Vuepress","博客"],"title":"解决一台电脑实现多个Github账号发布博客","uri":"/mac%E5%A4%9A%E4%B8%AAgithub%E8%B4%A6%E5%8F%B7%E5%8F%91%E5%B8%83%E5%A4%9A%E4%B8%AA%E5%8D%9A%E5%AE%A2/"},{"categories":["技术"],"content":"关于Hugo Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。 我选择hugo写博客，主要原因是因为它快！ ","date":"2022-06-10","objectID":"/mac%E5%A4%9A%E4%B8%AAgithub%E8%B4%A6%E5%8F%B7%E5%8F%91%E5%B8%83%E5%A4%9A%E4%B8%AA%E5%8D%9A%E5%AE%A2/:2:2","tags":["Github Pages","Git","Hugo","Vuepress","博客"],"title":"解决一台电脑实现多个Github账号发布博客","uri":"/mac%E5%A4%9A%E4%B8%AAgithub%E8%B4%A6%E5%8F%B7%E5%8F%91%E5%B8%83%E5%A4%9A%E4%B8%AA%E5%8D%9A%E5%AE%A2/"},{"categories":["技术"],"content":"关于Vuepress VuePress 需要nodejs，非常适合书写技术文档 ","date":"2022-06-10","objectID":"/mac%E5%A4%9A%E4%B8%AAgithub%E8%B4%A6%E5%8F%B7%E5%8F%91%E5%B8%83%E5%A4%9A%E4%B8%AA%E5%8D%9A%E5%AE%A2/:2:3","tags":["Github Pages","Git","Hugo","Vuepress","博客"],"title":"解决一台电脑实现多个Github账号发布博客","uri":"/mac%E5%A4%9A%E4%B8%AAgithub%E8%B4%A6%E5%8F%B7%E5%8F%91%E5%B8%83%E5%A4%9A%E4%B8%AA%E5%8D%9A%E5%AE%A2/"},{"categories":["技术"],"content":"我的环境 操作系统：macOS Catalina 版本10.15.4 我的Hugo博客：hugo博客 我的Vuepress博客：vuepress博客 ","date":"2022-06-10","objectID":"/mac%E5%A4%9A%E4%B8%AAgithub%E8%B4%A6%E5%8F%B7%E5%8F%91%E5%B8%83%E5%A4%9A%E4%B8%AA%E5%8D%9A%E5%AE%A2/:2:4","tags":["Github Pages","Git","Hugo","Vuepress","博客"],"title":"解决一台电脑实现多个Github账号发布博客","uri":"/mac%E5%A4%9A%E4%B8%AAgithub%E8%B4%A6%E5%8F%B7%E5%8F%91%E5%B8%83%E5%A4%9A%E4%B8%AA%E5%8D%9A%E5%AE%A2/"},{"categories":["技术"],"content":"解决思路 思路就是：管理两个SSH key ","date":"2022-06-10","objectID":"/mac%E5%A4%9A%E4%B8%AAgithub%E8%B4%A6%E5%8F%B7%E5%8F%91%E5%B8%83%E5%A4%9A%E4%B8%AA%E5%8D%9A%E5%AE%A2/:3:0","tags":["Github Pages","Git","Hugo","Vuepress","博客"],"title":"解决一台电脑实现多个Github账号发布博客","uri":"/mac%E5%A4%9A%E4%B8%AAgithub%E8%B4%A6%E5%8F%B7%E5%8F%91%E5%B8%83%E5%A4%9A%E4%B8%AA%E5%8D%9A%E5%AE%A2/"},{"categories":["技术"],"content":"1 密钥/Git配置 1.1 创建新的密钥 先查看当前已有的密钥 [老密钥] ls ~/.ssh/ 显示id_rsa 与 id_rsa.pub说明已经有一对密钥 milo@MilodeMacBook-Pro ~ %ls ~/.ssh/ config id_rsa id_rsa.pub ⚠️注意：如果没有 [老密钥]，就生成两个**[新密钥]**即可，一个叫id_rsa，另一个叫id_rsa_c 生成新的密钥 [新密钥] cd ~/.ssh/ ssh-keygen -t rsa -C \"你的邮箱xxx@xx.com\" ⚠️注意：当出现下面这一句时，需要给新的密钥起名字，比如：id_rsa_c Generating public/private rsa key pair. Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): id_rsa_c 然后不用填写，一路回车就行 验证密钥是否生成 ls ~/.ssh/ 显示id_rsa、id_rsa.pub与id_rsa_c、id_rsa_c.pub说明已经有两对密钥 milo@MilodeMacBook-Pro ~ %ls ~/.ssh/ config id_rsa id_rsa.pub id_rsa_c id_rsa_c.pub 1.2 配置两个密钥 查看.ssh/根路径下, 有没有config文件,没有则创建一个config文件(config本身无后缀名) touch config 用Text打开config open -a TextEdit config 写入如下配置 #第一个账号，默认使用的账号，不用做任何更改 Host github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa #第二个新账号，#\"xxxxx\"为前缀名，可以任意设置，要记住，后面需要用到 Host xxxxx.github.com HostName github.com User git IdentityFile ~/.ssh/这里是你创建的新密钥的名称 例如 Host github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa Host vue.github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa_c 1.3 添加到SSH agent 先清空本地的 SSH 缓存 ssh-add -D 添加新的 SSH 密钥 到 SSH agent中 ssh-add xxxxxx #旧密钥名称，一般是id_rsa ssh-add xxxxxx #新创建的密钥名称 例如 ssh-add id_rsa ssh-add id_rsa_c ⚠️注意：如果出现错Could not open a connection to your authentication agent.，先执行ssh-agent bash，再执行以上命令，虽然我没遇到这个错误😄 1.4 新的SSH-GitHub 之前我们生成新密钥的时候执行了cd ~/.ssh/，所以我们当前应该在.ssh目录下 milo@MilodeMacBook-Pro ~/.ssh % 在.ssh目录下找到创建的新的公钥id_rsa_c.pub，用Text打开它，并把里面的内容复制 open -a TextEdit id_rsa_c.pub 打开新GitHub账号主页 Settings —\u003e SSH and GPG keys —\u003e 点击New SSH key title可以随便填，将刚复制的内容粘贴到Key那里，点击Add Key保存即可 然后回到命令行验证一下是不是设置好了 ssh -T git@github.com #老密钥的ssh_key验证 ssh -T git@xxxxxxx.github.com #新密钥的ssh_key验证 例如 ssh -T git@github.com #老密钥的ssh_key验证 Hi Milo980412! You've successfully authenticated, but GitHub does not provide shell access. ssh -T git@vue.github.com #新密钥的ssh_key验证 Hi MiloReact! You've successfully authenticated, but GitHub does not provide shell access. ⚠️注意：如果**[老密钥]没有验证成功，把[老密钥]**也执行一遍上述过程 1.5 Git配置更改 如果已经设置了全局，取消全局用户名和邮箱配置 git config --global --unset user.name git config --global --unset user.email ","date":"2022-06-10","objectID":"/mac%E5%A4%9A%E4%B8%AAgithub%E8%B4%A6%E5%8F%B7%E5%8F%91%E5%B8%83%E5%A4%9A%E4%B8%AA%E5%8D%9A%E5%AE%A2/:3:1","tags":["Github Pages","Git","Hugo","Vuepress","博客"],"title":"解决一台电脑实现多个Github账号发布博客","uri":"/mac%E5%A4%9A%E4%B8%AAgithub%E8%B4%A6%E5%8F%B7%E5%8F%91%E5%B8%83%E5%A4%9A%E4%B8%AA%E5%8D%9A%E5%AE%A2/"},{"categories":["技术"],"content":"2 Hugo和Vuepress设置 这边讲一下怎么在博客（本地仓库）使用我们配置好的两个SSH Key 2.1 重新设置Git配置 设置全局用户名和邮箱配置 git config --global user.name git config --global user.email 例如 git config --global \"Milo980412\" git config --global XXX@XX.com ⚠️注意：1.5 Git配置更改 中如果全局设置没啥问题的 1.5中就不用更改了，这里也不用重新设置了 2.2 Git命令push博客项目 一般我们push更新Hugo博客内容的流程是 # 生成静态文件 hugo --theme=LoveIt --baseUrl=\"https://milo980412.github.io\" # 进入生成的文件夹 cd public # 创建本地代码仓库 git init # 将修改的文件保存到暂存区 git add -A # 需要将文件提交到本地仓库 git commit -m 'deploy' # 推送代码，如果发布到 https://\u003cUSERNAME\u003e.github.io git push -f git@github.com:Milo980412/Milo980412.github.io.git master 一般我们push更新Vuepress博客内容的流程是 # 生成静态文件 npm run docs:build # 进入生成的文件夹 cd docs/.vuepress/dist # 创建本地代码仓库 git init # 将修改的文件保存到暂存区 git add -A # 需要将文件提交到本地仓库 git commit -m 'deploy' # 如果发布到 https://\u003cUSERNAME\u003e.github.io git push -f git@github.com:MiloReact/MiloReact.github.io.git master ⚠️注意：**[老密钥]的push没有区别，但是[新密钥]**的push有一点不同 这里我的vuepress是我的**[新密钥]，在git push时，git地址要写我们在1.2 配置两个密钥**时带有前缀的vue.github.com，如下所示 git push -f git@vue.github.com:MiloReact/MiloReact.github.io.git master 谁是新密钥就改谁的push命令就行，到此为止就解决了一台电脑实现多个Github账号发布博客 2.3 小建议 我不太喜欢用自动化部署，我喜欢用脚本，比如我在博客项目根目录创建一个deploy.sh文件，命令如下 Hugo # 生成静态文件 hugo --theme=LoveIt --baseUrl=\"https://milo980412.github.io\" # 进入生成的文件夹 cd public # 创建本地代码仓库 git init # 将修改的文件保存到暂存区 git add -A # 需要将文件提交到本地仓库 git commit -m 'deploy' # 推送代码，如果发布到 https://\u003cUSERNAME\u003e.github.io git push -f git@github.com:Milo980412/Milo980412.github.io.git master Vuepress # 生成静态文件 npm run docs:build # 进入生成的文件夹 cd docs/.vuepress/dist # 创建本地代码仓库 git init # 将修改的文件保存到暂存区 git add -A # 需要将文件提交到本地仓库 git commit -m 'deploy' # 如果发布到 https://\u003cUSERNAME\u003e.github.io git push -f git@vue.github.com:MiloReact/MiloReact.github.io.git master 执行脚本完成push更新 ./deploy.sh ","date":"2022-06-10","objectID":"/mac%E5%A4%9A%E4%B8%AAgithub%E8%B4%A6%E5%8F%B7%E5%8F%91%E5%B8%83%E5%A4%9A%E4%B8%AA%E5%8D%9A%E5%AE%A2/:3:2","tags":["Github Pages","Git","Hugo","Vuepress","博客"],"title":"解决一台电脑实现多个Github账号发布博客","uri":"/mac%E5%A4%9A%E4%B8%AAgithub%E8%B4%A6%E5%8F%B7%E5%8F%91%E5%B8%83%E5%A4%9A%E4%B8%AA%E5%8D%9A%E5%AE%A2/"},{"categories":["工具"],"content":"npm基本命令","date":"2022-06-09","objectID":"/npm%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/","tags":["NodeJS","npm","yarn"],"title":"npm基本命令","uri":"/npm%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["工具"],"content":"NPM是什么？ 它是一个命令行工具，npm已经被全球超过1100万开发人员所依赖，- 拥有超过一百万个软件包，是世界上最大的软件注册表。也可以形象的理解为一个应用商城，我们可以在里面下载各种已经编写好的代码，像常用的jQuery，webpack等等。官网链接(opens new window) ","date":"2022-06-09","objectID":"/npm%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:1:0","tags":["NodeJS","npm","yarn"],"title":"npm基本命令","uri":"/npm%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["工具"],"content":"NPM的安装 npm是Node.js (opens new window)默认的软件包管理系统，安装完node后，会默认安装好npm 我用的homebrew在我的Mac上安装的node brew install node 然后用命令查看node版本和npm版本 node -v //v18.2.0 npm -v //8.9.0 使用命令npm i npm -g全局安装npm，会默认更新最新版本 ","date":"2022-06-09","objectID":"/npm%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:2:0","tags":["NodeJS","npm","yarn"],"title":"npm基本命令","uri":"/npm%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["工具"],"content":"NPM 的基本使用 npm -v ：通过==查看版本==，看npm是否安装成功 npm install \u003cModule Name\u003e： 使用 npm命令==安装模块==，例如npm install jquery npm uninstall \u003cModule Name\u003e： 使用命令==卸载模块==，例如npm uninstall jquery npm update \u003cModule Name\u003e： 使用命令==更新模块==，例如npm update jquery npm install \u003cModule Name\u003e -g ： 可以直接在命令行里使用，安装在==全局== npm list -g：查看所有全局安装的模块 npm list vue：查看某个模块的==版本号== npm -g install npm@5.9.1：（@后跟版本号）这样我们就可以更新npm版本，==指定安装版本号== npm install -save moduleName：-save 在package文件的dependencies节点写入依赖。默认值 npm install -save-dev moduleName ：-save-dev 在package文件的devDependencies节点写入依赖 dependencies：==运行时==的依赖，发布后，即生产环境下还需要用的模块 devDependencies：==开发时==的依赖。里面的模块是开发时用的，发布时用不到它。 ","date":"2022-06-09","objectID":"/npm%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:3:0","tags":["NodeJS","npm","yarn"],"title":"npm基本命令","uri":"/npm%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["工具"],"content":"NPM 镜像的设置和查看 查看镜像配置结果 ：npm config get registry 将npm设置为淘宝镜像：npm config set registry https://registry.npm.taobao.org --global 使用nrm工具切换淘宝源：npx nrm use taobao 切换到官方源：npx nrm use npm ","date":"2022-06-09","objectID":"/npm%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:4:0","tags":["NodeJS","npm","yarn"],"title":"npm基本命令","uri":"/npm%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["工具"],"content":"Package.json 属性说明 name ：包名。 version ：包的版本号。 description ：包的描述。 homepage ：包的官网 url 。 author ：包的作者姓名。 dependencies ：依赖包列表 repository：包代码存放的地方的类型。 main ：main 字段指定了程序的主入口文件，require('moduleName')就会加载这个文件。 keywords ：关键字 注意： package.json文件中版本号的说明，安装的时候代表不同的含义： “7.14.0” 表示安装指定的7.14.0版本 “~7.14.0” 表示安装 7.0.x 中最新的版本 “^7.14.0” 表示安装7.x.x中最新的版本 ==特别注意==：当我们将代码文件拷贝给别人时，如果只拷贝了package.json文件，可以使用命令npm install会直接安装package.json下的所有依赖 yarn yarn解决了npm的一些缺陷！ ","date":"2022-06-09","objectID":"/npm%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:5:0","tags":["NodeJS","npm","yarn"],"title":"npm基本命令","uri":"/npm%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["工具"],"content":"yarn 安装 在有了npm的基础上这个就很简单了 使用npm安装npm install -g yarn 查看版本：yarn --version 淘宝源安装： 分别运行一下两行命令： yarn config set registry https://registry.npm.taobao.org -g yarn config set sass_binary_site http://cdn.npm.taobao.org/dist/node-sass -g 成功提示：success Set \"registry\" to \"https://registry.npm.taobao.org\". ","date":"2022-06-09","objectID":"/npm%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:6:0","tags":["NodeJS","npm","yarn"],"title":"npm基本命令","uri":"/npm%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["工具"],"content":"yarn的基本使用 yarn init：初始化项目 同npm init，执行输入信息后，会生成package.json文件 yarn install：安装package.json里所有包，并将包及它的所有依赖项保存进yarn.lock yarn install --flat：安装一个包的单一版本 yarn install --force ：强制重新下载所有包 yarn install --production：只安装dependencies里的包 yarn install --no-lockfile：不读取或生成yarn.lock yarn install --pure-lockfile：不生成yarn.lock yarn add [package]： 在当前的项目中添加一个依赖包，会自动更新到package.json和yarn.lock文件中 yarn add [package]@[version]：安装指定版本，这里指的是主要版本，如果需要精确到小版本，使用-E参数 yarn add [package]@[tag] ：安装某个tag（比如beta,next或者latest） yarn add --dev/-D： 加到 devDependencies yarn add --peer/-P ：加到 peerDependencies yarn add --optional/-O ：加到 optionalDependencies ","date":"2022-06-09","objectID":"/npm%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:7:0","tags":["NodeJS","npm","yarn"],"title":"npm基本命令","uri":"/npm%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["工具"],"content":"yarn的优点 速度快 安装版本统一 更简洁的输出 多注册来源处理 更好的语义化 ","date":"2022-06-09","objectID":"/npm%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:8:0","tags":["NodeJS","npm","yarn"],"title":"npm基本命令","uri":"/npm%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["技术"],"content":"进程和线程的区别","date":"2022-06-08","objectID":"/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/","tags":["操作系统"],"title":"进程和线程的区别","uri":"/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["技术"],"content":"经典面试题 进程与线程之间有什么区别？ 扩展 什么是缓冲区溢出？ 进程之间如何进行交互？ 线程之间如何进行交互？ 面试时不可避免会被问到这个问题，Milo将自己的理解记录一下。 ","date":"2022-06-08","objectID":"/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/:1:0","tags":["操作系统"],"title":"进程和线程的区别","uri":"/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["技术"],"content":"类比理解 1.计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。 2.假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。 3.进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。 4.一个车间里，可以有很多工人。他们协同完成一个任务。 5.线程就好比车间里的工人。一个进程可以包括多个线程。 6.车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。 7.可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。 8.一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫\"互斥锁\"（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。 9.还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。 10.这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做\"信号量\"（Semaphore），用来保证多个线程不会互相冲突。 不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。 11.操作系统的设计，因此可以归结为三点： 以多进程形式，允许多个任务同时运行； 以多线程形式，允许单个任务分成不同的部分运行； 提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。 ","date":"2022-06-08","objectID":"/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/:2:0","tags":["操作系统"],"title":"进程和线程的区别","uri":"/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["技术"],"content":"面试回答 进程是程序在执行过程中分配和管理资源的基本单位，每一个进程都有自己的地址空间，至少有5种基本状态：初始态、执行态、等待状态、就需状态和终止状态 线程是CPU调度和分派的基本单位，它可与同属一个进程的其他线程共享进程所拥有的全部资源 联系 线程是进程的一部分，一个线程只能属于一个进程，而一个进程可以有多个线程 区别 进程是操作系统分配和管理资源的基本单位，线程是任务调度和执行的基本单位 进程有独立的地址空间，而线程只能共享所属进程的资源 进程之间的切换开销大，线程之间的切换开销小 线程是为了在系统层面实现并发，提高硬件利用率 进程是为隔离资源，保障一些资源崩溃了后被回收，不影响其他程序 扩展 缓冲区溢出：我们有个地方要输入用户名，本来是用来存数据的地方。 然后黑客把数据输入的特别长。这个长度超出了我们给数据存储的内存区，这时候跑到了 我们给程序分配的一部分内存中。黑客就可以通过这种办法将他所要运行的代码 写入到用户名框中，来植入进来。我们的解决方法就是，用用户名的长度来限制不要超过 用户名的缓冲区的大小来解决。 进程之间通过TCP/IP的端口来进行交互 线程的通信就比较简单，有一大块共享的内存，只要大家的指针是同一个就可以看到各自的内存 ","date":"2022-06-08","objectID":"/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/:3:0","tags":["操作系统"],"title":"进程和线程的区别","uri":"/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["算法"],"content":"LeetCode 0003.无重复字符的最长子串","date":"2022-06-07","objectID":"/leetcode-0003.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","tags":["leetcode","算法"],"title":"力扣 0003.无重复字符的最长子串","uri":"/leetcode-0003.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["算法"],"content":"3.无重复字符的最长子串 问题 给定一个字符串s,请你找出其中不含有重复字符的最长子串的长度。 示例1: 输入: s = \"abcabcbb\" 输出: 3 解释:因为无重复字符的最长子串是\"abo\",所以其长度为3。 示例2: 输入: s=\"bbbbb\" 输出: 1 解释:因为无重复字符的最长子串是\"b\",所以其长度为1。 示例3: 输入: s=\"pwwkew\" 输出: 3 解释:因为无重复字符的最长子串是\"wke\",所以其长度为3。 请注意,你的答案必须是子串的长度,\"pwke\"是一个子序列,不是子 串。 ","date":"2022-06-07","objectID":"/leetcode-0003.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/:1:0","tags":["leetcode","算法"],"title":"力扣 0003.无重复字符的最长子串","uri":"/leetcode-0003.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["算法"],"content":"法一：滑动窗口+哈希集合判断重复 var lengthOfLongestSubstring = function(s) { let set = new Set(); //创建一个set集合 let i = 0 ,j = 0; //创建两个指针,i指针随着for循环遍历字符串，j指针指向字符串的开头,即滑动窗口 let maxLength = 0; //记录最大长度 if(s.length === 0){ return 0; } for(let i = 0; i\u003c s.length; i++){ if(!set.has(s[i])){ //如果set理没有s[i]，说明目前为止没有重复的字符 set.add(s[i]); //把它添加到set里 maxLength = Math.max(maxLength,set.size); //更新最大不重复字符的数量，如果比之前大就更新 }else{ while(set.has(s[i])){ //如果set里有s[i]，开始以下操作，直到set里没有s[i]为止 set.delete(s[j]); //从set里开始删除s[j] j++; //并且开始递增j，即把j指针右移 } set.add(s[i]); //set里没有之前重复的s[i]后，添加新的s[i],开始新的一轮 } } return maxLength; //输出不含有重复字符的最长子串的长度 }; 时间复杂度： O(N)，N是字符串的长度，两个指针分别会遍历整个字符串一次。 空间复杂度： O(∣Σ∣)，字符集这里默认为ASCII码，即[0,128),所以字符集大小为128。 创建一个set集合。 创建两个指针,i指针随着for循环遍历字符串，j指针指向字符串的开头,即滑动窗口。 如果set理没有s[i]，说明目前为止没有重复的字符，把它添加到set里，然后更新最大不重复字符的数量，如果比之前大就更新。 如果set里有s[i]，则从set里开始删除s[j]，并且开始递增j，即把j指针右移，直到set里没有s[i]为止，添加新的s[i],开始新的一轮。 直到遍历完整个字符串，最后输出最大不重复字符的数量。 ","date":"2022-06-07","objectID":"/leetcode-0003.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/:1:1","tags":["leetcode","算法"],"title":"力扣 0003.无重复字符的最长子串","uri":"/leetcode-0003.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["算法"],"content":"法二：官方答案 var lengthOfLongestSubstring = function(s) { // 哈希集合，记录每个字符是否出现过 const occ = new Set(); const n = s.length; // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动 let rk = -1, ans = 0; for (let i = 0; i \u003c n; ++i) { if (i != 0) { // 左指针向右移动一格，移除一个字符 occ.delete(s.charAt(i - 1)); } while (rk + 1 \u003c n \u0026\u0026 !occ.has(s.charAt(rk + 1))) { // 不断地移动右指针 occ.add(s.charAt(rk + 1)); ++rk; } // 第 i 到 rk 个字符是一个极长的无重复字符子串 ans = Math.max(ans, rk - i + 1); } return ans; }; ","date":"2022-06-07","objectID":"/leetcode-0003.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/:1:2","tags":["leetcode","算法"],"title":"力扣 0003.无重复字符的最长子串","uri":"/leetcode-0003.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":["工具"],"content":"Git基本命令","date":"2022-06-06","objectID":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","tags":["Git"],"title":"Git基本命令","uri":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":" 引用 笔记来源 小丞前端日记 ","date":"2022-06-06","objectID":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:0:0","tags":["Git"],"title":"Git基本命令","uri":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"引言 Git 作为目前最强大的代码管理工具，相信大家都很熟悉了。它在我们的日常工作中起着至关重要的作用，我们可以用它来实现多人开发。也可以用来方便我们自己，在我们坐车的时候，可以用手机看看自己刚刚上传的代码。这些都是不错的选择，下面我们就结合场景来学习一下 Git 的基本命令 ","date":"2022-06-06","objectID":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:1:0","tags":["Git"],"title":"Git基本命令","uri":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"场景实战 我们的第一个任务是：将代码提交到 Gitee / Github 远程仓库中 ","date":"2022-06-06","objectID":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:0","tags":["Git"],"title":"Git基本命令","uri":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"1. 创建远程代码仓库 首先我们需要创建一个远程仓库，这里我选择的是 Gitee ","date":"2022-06-06","objectID":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:1","tags":["Git"],"title":"Git基本命令","uri":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"2. 全局设置 Git 在使用 Git 之前，我们需要设置用户名和邮箱，以方便记录代码的提交者是谁 用户名 git config --global user.name \"your_username\" 邮箱 git config --global user.email \"your_email\" ","date":"2022-06-06","objectID":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:2","tags":["Git"],"title":"Git基本命令","uri":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"3. 创建本地代码仓库 在配置好全局设置后，我们可以新建一个文件夹，用来当作本地代码仓库 建好文件夹后，我们需要初始化代码仓库 git init 这时候在这个文件夹下就会创建一个隐藏的 .git 文件，这样就创建好了 ","date":"2022-06-06","objectID":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:3","tags":["Git"],"title":"Git基本命令","uri":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"4. 暂存文件 这时候我们在当前文件夹下创建一个文件 touch README.md 然后随意添加点文件内容 将修改的文件保存到暂存区 git add . . 表示目录下的全部文件，也就是提交所有 如果只想上传某个可以这样 git add README.md ","date":"2022-06-06","objectID":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:4","tags":["Git"],"title":"Git基本命令","uri":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"5. 提交修改 将文件保存到暂存区之后，我们需要将文件提交到本地仓库 git commit -m \"first commit\" 引号内容是我们此次提交的注释，解释这次提交修改的内容之类的 在某些考核的过程中，可能会限制代码提交的次数 我们可以将此次的修改加到上一次提交中 git commit --amend ","date":"2022-06-06","objectID":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:5","tags":["Git"],"title":"Git基本命令","uri":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"6. 与远程仓库建立连接 在推送代码之前我们需要与远程仓库建立连接，不然本地参考怎么知道上传到哪里呢？ git remote add origin 仓库地址 仓库地址在 Gitee 上可以查看 ","date":"2022-06-06","objectID":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:6","tags":["Git"],"title":"Git基本命令","uri":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"7. 推送代码 在提交代码到本地仓库后，我们需要将它推送到远程仓库中 git push -u origin master 注意：第一次推送分支时，加上 -u ，在推送分支内容的同时，会与远端的分支关联起来，下次提交不需 -u 可以直接 git push origin master ","date":"2022-06-06","objectID":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:7","tags":["Git"],"title":"Git基本命令","uri":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"8. 查看远程仓库 这时候我们可以在远程仓库上，看到自己刚刚上传的代码 这样我们就完成了我们的第一个任务，上传代码 接收第二个任务，现在我们的项目有两个开发人员，我们需要创建一个分支，用于平时的开发 ","date":"2022-06-06","objectID":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:8","tags":["Git"],"title":"Git基本命令","uri":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"9. 创建分支 创建分支可以保证各个功能的相对独立，不用一起修改同个分支的代码文件 我们可以先查看当前仓库下的所有分支 git branch 创建一个 dev 分支 git branch dev 切换到 dev 分支 git checkout \"dev\" 以上的分支操作，还可以采用其他的方法 创建分支并切换到该分支 git checkout -b \"分支名\" 也可以采用 switch （推荐） git switch -c \"分支名\" 切换分支也可以采用 switch git switch 分支名 然后我们可以通过切换到 dev 分支上，进行正常的提交推送，就像这样 ","date":"2022-06-06","objectID":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:9","tags":["Git"],"title":"Git基本命令","uri":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"10. 合并分支 平时我们在 dev 分支上开发，到一定时候是，我们需要将我们的分支合并到主干分支上 首先需要切换到 master 分支 git checkout master 然后合并 dev 分支 git merge dev 合并完成后要 push 到远程仓库 git push origin master ","date":"2022-06-06","objectID":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:10","tags":["Git"],"title":"Git基本命令","uri":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"11. 删除分支 当我们不再需要这个分支时，我们就可以删除它 git branch -D 分支名 这只是删除了本地的分支 我们还要删除远程仓库的分支 git push origin --delete 分支名 此时已删除成功 我们成功的学会了第二个任务，现在你的同事推送了代码我们需要同步一下 ","date":"2022-06-06","objectID":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:11","tags":["Git"],"title":"Git基本命令","uri":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"12. 拉取代码 直接拉取就好了 git pull 在我们多人开发的过程中，上传代码前一定要先拉取远程仓库的代码 以上就是一个拉取上传的完整操作了 下面是一些其他的命令，可以结合使用 ","date":"2022-06-06","objectID":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:12","tags":["Git"],"title":"Git基本命令","uri":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"13. 其他命令 1. 查看文件状态 git status 2. 查看提交历史记录 git log 3. 代码回滚 版本号可以在 gitee 上看到，也可以在 log 中看到 git checkout 版本号 4. 克隆项目 git clone 地址 指定克隆下来的文件位置 git clone git地址 '文件存放路径' 5. 储藏修改 把本地修改储藏起来，等恢复后再继续工作 git stash 6. 查看储藏信息 git stash list 7. 恢复储藏信息 git stash apply 8. 删除储藏内容 git stash drop ","date":"2022-06-06","objectID":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:13","tags":["Git"],"title":"Git基本命令","uri":"/git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["算法"],"content":"LeetCode 0002.两数相加","date":"2022-06-06","objectID":"/leetcode-0002.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/","tags":["leetcode","算法"],"title":"力扣 0002.两数相加","uri":"/leetcode-0002.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"categories":["算法"],"content":"2.两数相加 问题 给你两个非空的链表,表示两个非负的整数。它们每位数字都是按照逆序的方式存储的,并且每个节点只能存储一位数字。 请你将两个数相加,并以相同形式返回一个表示和的链表。 信息 你可以假设除了数字0之外,这两个数都不会以0开头。 示例1: 输入: L1 = [2,4,3], L2 = [5,6,4] 输出: [7,0,8] 解释: 342 + 465 = 807. 示例2: 输入: L1= [0], L2 = [0] 输出: [0] 示例3: 输入: L1 = [9,9,9,9,9,9,9], L2 = [9,9,9,9] 输出: [8,9,9,9,0,0,0,1] ","date":"2022-06-06","objectID":"/leetcode-0002.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/:1:0","tags":["leetcode","算法"],"title":"力扣 0002.两数相加","uri":"/leetcode-0002.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"categories":["算法"],"content":"法一：利用官方构造函数设置结点 var addTwoNumbers = function(l1, l2) { let head = new ListNode(); //创建一个新结点head let tail = head; //head和tail都在新结点的位置 let carry = 0; //进位carry初始化为0 //同时遍历l1和l2直至到达它们的尾端 while(l1 != null || l2 != null){ let sum = 0; if(l1 != null){ sum += l1.val; //计算相同位置的和 l1 = l1.next; //将l1前进到下一个结点 } if(l2 != null){ sum += l2.val; //计算相同位置的和 l2 = l2.next; //将l2前进到下一个结点 } sum += carry; //与当前位置的进位值相加 tail.next = new ListNode(sum % 10) //创建一个数值为sum%10 取模的新结点，并将其设置为当前结点的下一个结点，答案链表处相应的数字为(n1+n2+carry)%10 carry = Math.floor(sum / 10); //新的进位符为(n1+n2+carry)/10 取整 tail = tail.next; //将当前结点前进到下一个结点 } if(carry \u003e 0){ tail.next = new ListNode(carry); //检查carry是否存在进位，是则添加一个数值为carry的新结点 } return head.next; } 时间复杂度： O(max(m,n))，其中m和n分别为两个链表的长度，我们要遍历两个链表的全部位置，而处理每个位置只需要O(1)时间。 空间复杂度： O(1)，返回值不计入空间复杂度。 由于输入的两个链表都是逆序存储数字的位数的，因此两个链表中同一位置的数字可以直接相加。 我们同时遍历两个链表，逐位计算它们的和，并与当前位置的进位值相加。 创建一个数值为sum%10 取模的新结点tail，并将其设置为当前结点的下一个结点，答案链表处相应的数字为(n1+n2+carry)%10 新的进位符为(n1+n2+carry)/10 取整 此外，链表遍历结束后，检查carry是否存在进位，是则添加一个数值为carry的新结点 ","date":"2022-06-06","objectID":"/leetcode-0002.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/:2:0","tags":["leetcode","算法"],"title":"力扣 0002.两数相加","uri":"/leetcode-0002.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"categories":["算法"],"content":"官方构造函数 function ListNode(val, next) { this.val = val === undefined ? 0 : val this.next = next === undefined ? null : next } 利用构造函数，生成结点，把链表里的数存进去 tail.next = new ListNode(sum % 10) ","date":"2022-06-06","objectID":"/leetcode-0002.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/:2:1","tags":["leetcode","算法"],"title":"力扣 0002.两数相加","uri":"/leetcode-0002.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"categories":["算法"],"content":"法二：官方答案 var addTwoNumbers = function(l1, l2) { let head = null, tail = null; //当前结点初始化为空结点 let carry = 0; //进位carry初始化为0 while(l1 != null || l2 != null){ //同时遍历l1和l2直至到达它们的尾端 const n1 = l1 ? l1.val : 0; const n2 = l2 ? l2.val : 0; const sum = n1 + n2 +carry; //逐位计算相同位置的和，并与当前位置的进位值相加 if(!head){ head = tail = new ListNode(sum % 10); //让head停在第一个结点的位置，tail同下 }else{ tail.next = new ListNode(sum % 10); //创建一个数值为sum%10 取模的新结点，答案链表处相应的数字为(n1+n2+carry)%10 tail = tail.next; //将当前结点前进到下一个结点 } carry = Math.floor(sum / 10); //新的进位符为(n1+n2+carry)/10 取整 if(l1){ l1 = l1.next; //将l1前进到下一个结点 } if(l2){ l2 = l2.next; //将l1前进到下一个结点 } } if(carry \u003e 0){ tail.next = new ListNode(carry); } return head; }; ","date":"2022-06-06","objectID":"/leetcode-0002.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/:3:0","tags":["leetcode","算法"],"title":"力扣 0002.两数相加","uri":"/leetcode-0002.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"categories":["前端"],"content":"Javascript中的高阶函数","date":"2022-06-05","objectID":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/","tags":["前端","JS"],"title":"Javascript中的高阶函数","uri":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"},{"categories":["前端"],"content":"高阶函数是指以函数作为参数的函数，并且可以将函数作为结果返回的函数。 ","date":"2022-06-05","objectID":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/:0:0","tags":["前端","JS"],"title":"Javascript中的高阶函数","uri":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"},{"categories":["前端"],"content":"1. 高阶函数 接受一个或多个函数作为输入 输出一个函数 至少满足以上一个条件的函数 在js的内置对象中同样存在着一些高阶函数，像数组的map，filter，reduce方法等，它们接受一个函数作为参数，并应用这个函数到列表的每一个元素 ","date":"2022-06-05","objectID":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/:1:0","tags":["前端","JS"],"title":"Javascript中的高阶函数","uri":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"},{"categories":["前端"],"content":"1.1 map map方法接收一个函数作为参数 ，遍历数组，并且返回一个新的数组，新的数组里的每个元素都执行map传入的函数。 let arr = [1, 2, 3, 4]; let arr1 = arr.map(item =\u003e item * 2) console.log(arr1);// [2, 4, 6, 8] 返回的是一个新数组arr1，==不改变原数组== 注意：如果传入的参数没有返回值，则数组的每一项都会是undefind 经典题目 console.log(['1','2','3'].map(parseInt)); 来看看上面这个代码输出什么 答案：[1, NaN, NaN] 解析 parseInt() 函数可解析一个字符串，并返回一个整数。 基数radix可选2到36之间的整数，当参数 radix 的值为 0，或没有设置该参数时，parseInt()会根据该字符串来判断数字的基数。 当忽略参数 radix , 默认的基数如下: 如果 字符串 以 “0x” 开头，parseInt() 会把 其余部分解析为十六进制的整数。 如果字符串以 0 开头，把其余部分解析为八进制或十六进制的数字。 如果字符串以 1 ~ 9 的数字开头，parseInt()将把它解析为十进制的整数 如果基数小于2或大于36，或者第一个非空白字符不能转换为数字，则返回NaN。 注意：基数可不是默认十进制 当我们把数组传入parseInt时，由于接收2个参数，会将数组的索引作为基数传给parseInt，所以实质上进行的是以下几步 parseInt('1', 0) parseInt('2', 1) parseInt('3', 2) 第一个parseInt，字符串为1，基数为0 被默认为十进制，所以返回1 第二个和第三个，因为基数不是0，且小于2，所以parseInt()会返回 NaN。 ","date":"2022-06-05","objectID":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/:1:1","tags":["前端","JS"],"title":"Javascript中的高阶函数","uri":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"},{"categories":["前端"],"content":"1.2 filter 用于筛选数组 filter方法接收一个函数作为参数，通过这个函数来指定筛选数组的规则，最后返回满足规则的新数组 在传入的函数中有3个参数可选 参数 描述 currentValue 必须。当前元素的值 index 可选。当前元素的索引值 arr 可选。当前元素属于的数组对象 注意： 不会检测空数组 不会改变原始数组 let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9] let arr1 = arr.filter(num =\u003e { return num \u003e 5 }) console.log(arr1);// [6, 7, 8, 9] ","date":"2022-06-05","objectID":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/:1:2","tags":["前端","JS"],"title":"Javascript中的高阶函数","uri":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"},{"categories":["前端"],"content":"1.3 reduce reduce能做的事情很多，但是我们平时都使用for循环之类的方法代替了，但是reduce真的高逼格 array.reduce(function(total, currentValue, currentIndex, arr), initialValue) 以上是在w3school中给出的reduce语法，这里我们常用的只有前面两个 参数 描述 total 必需。初始值, 或者计算结束后的返回值。 currentValue 必需。当前元素 let arr = [1, 2, 3, 4] let sum = arr.reduce((value, item) =\u003e { console.log(value, item); // 1 2 3 3 6 4 return value + item }) console.log(sum);// 10 从第四行的调试中可以看出reduce函数的执行过程，在没有初始值的情况下，将数组第一个值作为value第二个值作为item再依次往下遍历整个数组，将返回值作为value，数组的下一位作为item，直至遍历完成。 利用ruduce实现数组去重 let arr = [1,1,2,3,4,2,5,4]; let unique = arr.reduce(function (prev, item) { prev.indexOf(item) === -1 \u0026\u0026 prev.push(item); return prev; }, []); console.log(unique); // [1, 2, 3, 4, 5] 通过将空数组作为prev初始值 再通过indexOf判断数组中是否包含item，如果该元素不存在就返回-1， \u0026\u0026运算符第一条语句为true，则执行第二条，否则不执行 prev.push(item) 将item加入prev数组，最终返回数组prev 注意： indexOf()方法返回在数组中可以找到给定元素的第一个索引，如果该元素不存在，则返回-1。 关于\u0026\u0026运算符，第一条语句为true则执行第二条，否则不执行 ruduce的用法远不止这些，有兴趣的可以再了解以下~ 还有很多内置对象都是高阶函数，这里就不一一说明了，从上面的三个方法中，已经能很直观的感受到了函数接收函数作为参数，再返回值的过程，逼格很高也很好用 ","date":"2022-06-05","objectID":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/:1:3","tags":["前端","JS"],"title":"Javascript中的高阶函数","uri":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"},{"categories":["前端"],"content":"2. AOP面向切面编程 当我们需要使用一个公共函数，并且需要在这个函数执行前后添加自己的逻辑，通常我们的做法不能是直接修改这个函数，因为它是==公共函数==，这时候我们可以通过AOP的方法利用高阶函数和原型链的特点进行处理 把一些与业务无关的功能抽离出来，通过\"动态植入\"的方法，掺入到业务逻辑模块中。这样做的好处是保证业务逻辑模块的纯净和高内聚，其次可以方便的复用功能模块 需求：实现在函数==执行前==输出提示信息 这是一个函数 function say(who) { console.log(who + '：函数执行了'); } 实现在函数==执行前==输出提示信息 Function.prototype.before = function(callback) { return (...args) =\u003e { callback() this(...args) } } let whoSay = say.before(function() { console.log('你要被调用了'); }) whoSay('Milo') // 你要被调用了 // Milo：函数执行了 如果需要实现==后置通知==，只需要将callback()和this(…args)调换一下就可以了 Function.prototype.before = function(callback) { return (...args) =\u003e { this(...args) callback() } } // Milo：函数执行了 // 你要被调用了 实现的原理 在调用公共函数时，传入我们需要执行提前执行的函数，在内部函数执行前先调用该函数 ","date":"2022-06-05","objectID":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/:2:0","tags":["前端","JS"],"title":"Javascript中的高阶函数","uri":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"},{"categories":["前端"],"content":"3.偏函数 当一个函数有很多参数时，调用该函数就需要提供多个参数，如果可以减少参数的个数，就能简化该函数的调用，降低调用该函数的难度。 实现3个数求和 function sum(a, b, c){ return a + b + c; } console.log(sum(1, 2, 3)) // 6 在调用时我们需要传入3个参数，好像有些许麻烦，下面我们用偏函数的做法 创建一个新的partial函数，这个新函数可以固定住原函数的部分参数，从而减少调用时的输入的参数，让我们的调用更加简单 function sum(a, b, c) { return a + b + c } function partial(sum, c) { return function (a, b) { return sum(a, b, c) } } let partialSum = partial(sum, 3) console.log(partialSum(1,2))// 6 高阶函数除了可以接收函数作为参数外，还可以将函数作为结果返回，偏函数就是固定了函数的一个或多个参数，返回一个新的函数接收剩下的参数，以此来简化函数的调用。 Function.prototype.bind 函数就是一个偏函数的典型代表，它接受的第二个参数开始，为预先添加到绑定函数的参数列表中的参数 ","date":"2022-06-05","objectID":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/:3:0","tags":["前端","JS"],"title":"Javascript中的高阶函数","uri":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"},{"categories":["前端"],"content":"4. 函数柯里化 与偏函数不同，柯里化是把接收多个参数的函数转换成多个只接收一个参数的函数。 我们从一个简单的例子来认识函数柯里化 function add(a, b) { return a + b; } add(1, 2) // 3 普通做法 一次传入两个参数 // 假设有一个 curring 函数可以做到柯里化 function curring(){} curring(1)(2) // 我们通过这样的方式来接受参数，这样就实现了柯里化 接下来我们来看看利用柯里化来实现 function curring(x) { return return y =\u003e x + y } curring(1)(2) // =\u003e 3 ","date":"2022-06-05","objectID":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/:4:0","tags":["前端","JS"],"title":"Javascript中的高阶函数","uri":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"},{"categories":["前端"],"content":"4.1 函数柯里化的作用 要真正理解柯里化还是得看示例 4.1.1 参数复用 我们先看一段短短的代码，这段代码中，实现了输入输出个人信息的功能，通过myInfo函数将参数拼接返回，这实际上很简单，但是当有很多很多的用户信息时，需要一直传递着个人信息这个参数，这样显然是不合理的 function myInfo(inf, name, age) { return `${inf}：${name},${age}` } const myInfo1 = myInfo('个人信息', 'milo', '19') console.log(myInfo1); // 个人信息：milo,19 下面我们通过柯里化技术来解决 function myInfoCurry(inf) { return (name, age) =\u003e { return `${inf}：${name}${age}` } } let myInfoName = myInfoCurry('个人信息') const myInfo1 = myInfoName('milo', '19') const myInfo2 = myInfoName('Mmmy','19') console.log(myInfo2); // 个人信息：milo,19 console.log(myInfo1); // 个人信息：Mmmy,19 这个就是柯里化技术的作用之一了，参数复用，个人感觉还是很好用的 在上面代码的基础上，我们可以继续扩展我们的信息，就像这样，利用一个函数就可以实现多个功能 let myInfoHobby = myInfoCurry('爱好') const myInfo3 = myInfoHobby('看球赛','听歌') console.log(myInfo3); // 爱好：看球赛听歌 4.1.2 提前返回 这个特性是用来对浏览器的监听事件兼容性做一些判断并初始化，解决有些浏览器对addEventListener存在的兼容性问题，所以在使用之前做一次判断，之后就可以省略了 const whichEvent = (function () { if (window.addEventListener) { return function (ele, type, listener, useCapture) { ele.addEventListener(type, function (e) { listener.call(ele, e) }, useCapture) } } else if (window.attachEvent) { return function (ele, type, handler) { ele.attachEvent('on' + type, function (e) { handler.call(ele, e) }) } } })() 由于使用了立即执行函数，即使触发多次事件依旧只会触发一次if条件判断 4.1.3 延迟执行 下面我们通过一道例题来了解 编写一个add函数实现下面的功能 add(1)(2)(3) = 6 add(1, 2, 3)(4) = 10 add(1)(2)(3)(4)(5) = 15 function add(...args) { let inner = function () { args.push(...arguments); inner.toString = function () { return args.reduce((prev, cur) =\u003e { return prev + cur }) } return inner } return inner } console.log(add(1)(2)(3)); // f console.log(add(1)(2)(3).toString()); // 6 这段代码中涵盖的知识面很多，核心的部分在于inner.toString这里，利用了当返回一个函数时返回的是它的字符串形式，所以我们可以利用这个特性来自定义我们的返回值 ","date":"2022-06-05","objectID":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/:4:1","tags":["前端","JS"],"title":"Javascript中的高阶函数","uri":"/javascript%E4%B8%AD%E7%9A%84%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"},{"categories":["算法"],"content":"LeetCode 0001.两数之和","date":"2022-06-05","objectID":"/leetcode-0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","tags":["leetcode","算法"],"title":"力扣 0001.两数之和","uri":"/leetcode-0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"categories":["算法"],"content":"1.两数之和 问题 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。 信息 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 示例 2： 输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3： 输入：nums = [3,3], target = 6 输出：[0,1] ","date":"2022-06-05","objectID":"/leetcode-0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/:1:0","tags":["leetcode","算法"],"title":"力扣 0001.两数之和","uri":"/leetcode-0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"categories":["算法"],"content":"法一：暴力解法 var twoSum = function(nums, target) { for(let i = 0,len = nums.length; i \u003c len; i++){ for(let j = i+1; j \u003c len; j++){ if((target - nums[i]) == nums[j]){ return [i,j]; } } } return []; }; 时间复杂度： O(N2)，其中 N是数组中的元素数量。对于每一个元素 x，我们可以 O(1) 地寻找 target - x。两个循环，所以是O(N2)。 空间复杂度： O(1) 简单粗暴,2遍for循环逐个遍历判断。 ","date":"2022-06-05","objectID":"/leetcode-0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/:2:0","tags":["leetcode","算法"],"title":"力扣 0001.两数之和","uri":"/leetcode-0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"categories":["算法"],"content":"法二：哈希表（官方答案） var twoSum = function(nums, target) { let map = new Map(); for(let i = 0; i \u003c nums.length; i++){ if(map.has(target - nums[i])){ return [map.get(target - nums[i]),i]; }else{ map.set(nums[i],i); } } return []; } 时间复杂度： O(N)，其中 N是数组中的元素数量。对于每一个元素 x，我们可以 O(1) 地寻找 target - x。 空间复杂度： O(N)，其中 N是数组中的元素数量。主要为哈希表的开销。 一遍for循环搞定,将数字存在哈希表的键值对中,并判断target-nums[i]的结果在哈希表键值对中是否存在,是则说明找到匹配数字。 我们遍历到数字a时,用target减去a,就会得到b,若b存在于哈希表中,我们就可以直接返回结果了。若b不存在,那么我们需要将a存入哈希表,好让后续遍历的数字使用。 ","date":"2022-06-05","objectID":"/leetcode-0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/:3:0","tags":["leetcode","算法"],"title":"力扣 0001.两数之和","uri":"/leetcode-0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"categories":["算法"],"content":"LeetCode 刷题预备知识","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"时间复杂度 ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:1:0","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"一. 大 O 表示法 关于复杂度的计算，我们采用的是 大 O 表示法 ，它用来描述算法性能和复杂程度 常见的表示 符号大O标记法 名称 O(1) 常数 O(log N) 对数 O(N) 线性 O(N log N) 对数多项式 O(N^2) 二次 O(2^N) 指数 O(N!) 阶乘 大 O 表示法一般考虑的是 CPU 占用时间，它可以粗略的了解代码运行的时间效率 例如 function test(num){ return ++num; } 我们调用这个函数一次，执行时间是 t ，我们再调用一次，执行时间还是 t，和传入的参数无关， test 函数的性能都一样，因此它的复杂度为 O(1) 当循环 n 次时，就是 O(n) ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:1:1","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"二. 时间复杂度 大 O 表示法表明的是该段代码执行时间随数据规模增大的变化趋势，它的特点是 只关注量级最大的时间复杂度 常见的时间复杂度量级 O(1) \u003c O(logn) \u003c O(n) \u003c O(n^2) 对于 O(2)、O(3) 这些，我们都叫做 O(1) 常数级 例如： 1. O(1) let i = 0; i += 1; // 每次执行代码只执行一次 O(1) 这段代码每次只执行一次，因此为 O(1) 2. O(n) for (let j = 0; j \u003c n; j++) { console.log(j); } 再上面这段代码中，我们每次都需要执行 n 次的 log ，因此我们可以把它看作 O(n) 同样的我们再来看一个 let i = 0; i += 1; for (let j = 0; j \u003c navigator; j++) { console.log(j); } 这种代码我们经常写，前面是我们刚刚计算的 O(1)，后面是 O(n) ，它们并行排列，时间复杂度相加，取最大的那个 因此它的时间复杂度同样是 O(n) 3. O(log(n)) while (i \u003c n) { console.log(i); i *= 2; } 对于 log(n) 的情况，在个时间复杂度是很好的，当然 O(1) 是最好的，但是在解题的时候，如果能优化到 log(n) 也是很不错的了 那它是如何计算的呢？ 我们可以看到，这里采用了 变量i来控制循环的终止，每次循环体中，都需要 2 * i 的操作 因此对于时间复杂度的计算 2^t = n 解得 t = log(n) 4. O(n^2) for (let i = 0; i \u003c n; i++) { for (let j = 0; j \u003c n; j++) { console.log(i); } } 对于这种嵌套排列，时间复杂度是 n^2 ，外面一层 n ，里面一层 n 乘一下就是 n^2，冒泡排序的时间复杂度就是 O(n^2) 关于时间复杂度就介绍这么多，其他的思路都差不多 ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:1:2","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"空间复杂度 空间复杂度表示的是：存储空间随数据规模的增长趋势，在 LeetCode 中最直接的反应就是内存消耗 例如 1. O(1) let i = 0; 在这里我们申请了单个变量的内存空间，为 O(1) 2. O(n) let arr = [] for(let i = 0;i \u003c n;i++) { arr.push(i) } 像这样的一个数组，并给它填满值，n 越大，它需要分配的空间就越多，它的空间复杂度就是 O(n) 3. O(n^2) int arr = [][] // 遍历赋值 声明一个二维数组，填满值，它的空间复杂度就是 O(n^2) ，你可以理解为一个矩阵，n*n 为 n^2 ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:2:0","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"📌 总结 复杂度计算按最高阶来计算 时间、空间复杂度描述的都是随数据规模的变化趋势 时间复杂度的重点在于循环嵌套 空间复杂度关注于内存 ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:2:1","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"链表基础知识 链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。 链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。 使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。 但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的存取往往要在不同的排列顺序中转换。 链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。 链表有很多种不同的类型：单向链表，双向链表以及循环链表。 ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:3:0","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"二叉树(BT,Binary Tree) ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:4:0","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"满二叉树(Full Binary Tree) 叶子结点只能出现在最下层，其他层所有结点均有左子树和右子树，且所有层都达到该层能拥有的最大结点树数。它是完全二叉树的一种特殊情况。 官方定义： 如果一颗二叉树的结点要么是叶子结点，要么他有两个子结点，这样的树就是满二叉树。 ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:4:1","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"完全二叉树(Complete Binary Tree) 叶子结点只能出现在最下层和次下层，其他层所有结点均有左子树和右子树，且最下层的叶子结点集中在树的左部。 官方定义： 一颗深度为h的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这颗二叉树称为完全二叉树。 ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:4:2","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"二叉搜索树(BST,Binary Search Tree) 每个结点的左子树中所有结点的值均小于该结点的值，右子树中所有结点的值均大于该结点。 ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:5:0","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"二分搜索基础知识 练习： 给定一个 n个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1: 输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 示例 2: 输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:6:0","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"法一： var search = function(nums, target) { //定义左指针和右指针分别指向开头和结尾 let left =0, right = nums.length - 1; //当left\u003c=right while(left \u003c= right){ //mid=(left+right)/2,之所以写成下面的形式是防止超出整型范围，防止溢出。 mid = Math.floor(left + (right - left)/2); //如果找到了，就输出 if(nums[mid] == target){ return mid; //如果目标比mid小，要把右半边舍弃 }else if(target \u003c nums[mid]){ right = mid - 1;//mid以及mid右边都舍弃 //如果目标比mid大，要把左半边舍弃 }else{ left = mid + 1;//mid以及mid左半边都舍弃 } } //没找到输出-1 return -1; }; ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:6:1","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"Set基础知识 //创建一个Set const numberSet = new Set(); //添加，set不会添加重复的值 numberSet.add(1); //删除,成功返回ture，失败返回false numberSet.delete(1); //判断set里是否有这个值，有返回ture，没有返回false numberSet.has(1); //输出set里有几个元素 numberSet.size //遍历set中所有元素 numberSet.forEach(number=\u003e console.log(number)) // console.log(numberSet); 练习： //1.判断下面这段代码最终输出的值 const set = new Set(); set.add(1); set.add(1); set.add(\"1\"); console.log(set) 输出：{1,\"1\"} ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:7:0","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"Map基础知识 //创建一个Map const person = new Map(); //添加,如果重复set，会覆盖原来的值 person.set(\"name\",\"milo\"); person.set(\"age\",18); person.set(\"hooby\",[\"看老毕和鱼皮的视频\",\"睡觉\",\"打CSGO\"]) //删除,成功返回ture，失败返回false person.delete(\"age\") //获取Map里的某个值 person.get(\"name\"); //判断set里是否有这个值，有返回ture，没有返回false person.has(\"age\"); //输出set里有几个元素 person.size //遍历set中所有元素 person.forEach(person=\u003e console.log(person)) // console.log(person); 练习： //2.创建一个map，并且添加如下数据：1:“北京”，2:“上海”，3:“杭州”，（0，1，2均为数字）。然后删除掉第一个元素。 const cities = new Map(); cities.set(1,\"北京\"); cities.set(2,\"上海\"); cities.set(3,\"杭州\"); console.log(cities); 输出：{1 =\u003e '北京', 2 =\u003e '上海', 3 =\u003e '杭州'} cities.delete(1); console.log(cities); 输出：{2 =\u003e '上海', 3 =\u003e '杭州'} ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:8:0","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["算法"],"content":"let和const let和const的区别： Let可以重新赋值，Const不可以。 var a = 1; console.log(a); var b = \"hello\"; console.log(b); //let可以重新赋值 let c = 10; c = c + 1 ; console.log(c); //const不可以重新赋值。会报错 const d = \"hello\"; d = d + \"world\"; console.log(d); var和let、const的区别： var成功重复声明变量，let和const不可以 var productPrice = 5.99; // line 1000 var productPrice = 9.99; //重复声明了变量 // line 5000 productPrice++; console.log(productPrice); 输出：10.99 var的作用域范围是函数作用域范围 var price =1; function setPrice() { price++; } setPrice(); console.log(price) 输出：2 function setPrice() { var price =1; //而把var写在函数里面，外面的console.log就识别不到var price++; } setPrice(); console.log(price) 输出：Uncaught ReferenceError: price is not defined var price =1; function setPrice() { var price = 10; console.log(price); //var是函数作用域，所以这个console能访问到外面的也能访问到函数里的price console.log(window.price); //访问全局的price } setPrice(); console.log(price) 输出：10 1 1 let和const的作用域范围是块作用域 for(var i = 0; i \u003c 5; i++) {} console.log(i) //var是函数作用域，而for是块不是函数，所以var的i出了for这个块作用域，依然占用这个变量名，局部变量造成了全局污染。 输出：5 for(let i = 0; i \u003c 5; i++) {} console.log(i) //let是块作用域，就解决了局部变量污染全局变量的问题。 输出：Uncaught ReferenceError: i is not defined const price = 10; if(price \u003c 59){ const deliverFee = 5; price += deliverFee; } console.log(price); 输出：Uncaught TypeError: Assignment to constant variable. 解释：const不能重新赋值 let price = 10; if(price \u003c 59){ const deliverFee = 5; price += deliverFee; } console.log(price); console.log(deliverFee); 输出：15 Uncaught TypeError: Assignment to constant variable. 解释：let可以重复赋值,const是块作用域，所以最后一个console无法访问deliverFee 练习： 第一题：用let或const改写这段使用var的旧程序 var subtotal = 19.9; var tax = 0.13; var total = subtotal * ( 1 + tax); console.log(total) 输出：22.487 const subtotal = 19.9; const tax = 0.13; const total = subtotal * ( 1 + tax); console.log(total) 输出：22.487 let subtotal = 19.9; let tax = 0.13; let total = subtotal * ( 1 + tax); console.log(total) 输出：22.487 练习： 第二题：用let或const改写这段使用var的旧程序（注意函数作用域和块作用域的区别，必要时需要改变部分代码） 如果成绩哎60分以上，则课程pass var point = 95; if(point \u003e= 60){ var pass = true; } console.log(pass); 输出：true let point = 95; let pass = false; if(point \u003e= 60){ pass = true; } console.log(pass); 输出：true let point = 95; if(point \u003e= 60){ pass = true; console.log(pass); } 输出：true ","date":"2022-06-04","objectID":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:9:0","tags":["leetcode","算法"],"title":"LeetCode 刷题预备知识","uri":"/leetcode%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["前端"],"content":"JS从入门到精通","date":"2022-06-03","objectID":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/","tags":["前端","JS"],"title":"JS从入门到精通","uri":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"介绍 此项目为Milo在学习JS的过程中记录的笔记和源码，视频看的是B站上硅谷李立超老师的JavaScript基础，笔记参考了vectorX大佬的学习笔记，综合整理了笔记、源码code和相关面试题，面试题后面会持续更新，也会单独建立一个项目。另额外学习了JS高阶的内容如JS高阶函数、闭包、作用域链等..也会持续更新！ ","date":"2022-06-03","objectID":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:1:0","tags":["前端","JS"],"title":"JS从入门到精通","uri":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"其他地址 Github：https://github.com/Milo980412/NOTE_JS 语雀：https://www.yuque.com/u26476221/my897g Milo前端日记：JavaScript入门学习 ","date":"2022-06-03","objectID":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:2:0","tags":["前端","JS"],"title":"JS从入门到精通","uri":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"目录 JS基础 01_JS 简介 02_JS基础 03_JS运算 04_流程控制05-对象 06_函数 07_作用域 08_构造函数与原型对象 09_数组 10_call, apply 和 arguments 11_Date和Math 12_包装类和字符串 13_正则表达式 14_DOM 15_事件对象 16_滚轮事件与键盘事件 17_BOM 18_定时调用与延时调用 19_JSON JS高阶 JS高阶函数 ","date":"2022-06-03","objectID":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:3:0","tags":["前端","JS"],"title":"JS从入门到精通","uri":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"参考 视频链接 尚硅谷最新版JavaScript基础全套教程完整版(140集实战教学,JS从入门到精通) 笔记参考 来自vectorX大佬的学习笔记 ","date":"2022-06-03","objectID":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:4:0","tags":["前端","JS"],"title":"JS从入门到精通","uri":"/js%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["前端"],"content":"JS从入门到精通","date":"2022-05-15","objectID":"/htmlcss/","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"介绍 此项目为Milo学习HTML过程中记录的笔记和源码，视频看的B站尚硅谷李立超老师的HTML\u0026CSS视频，笔记参考vectorX大佬的学习笔记，综合整理了笔记、源码code和相关面试题，面试题后面会持续更新，也会单独建立一个项目 ","date":"2022-05-15","objectID":"/htmlcss/:1:0","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"其他地址 Github：https://github.com/Milo980412/NOTE_HTML-CSS 语雀：https://www.yuque.com/u26476221/cr1daz Milo前端日记：HTML\u0026CSS ","date":"2022-05-15","objectID":"/htmlcss/:2:0","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"目录 01_前端简介.md 02_前端开发准备.md 03_字符实体与语义标签.md 04_CSS语法与选择器.md 05_样式继承与其他概念.md 06_盒模型.md 07_实战练习.md 08_盒模型补径场实战.md 09_浮动.md 10_高度塌陷与BFC.md 11 定位.md 12_字体.md 13_背景.md 14雪碧图与渐变.md 15_表格.md 16_过渡与动画.md 17_变形:平转与缩放.md 18_less 简介.md 19_弹性盒简介.md 20_像素与视口.md 21_媒体查询.md ","date":"2022-05-15","objectID":"/htmlcss/:3:0","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"参考 学习视频 尚硅谷Web前端零基础入门HTML5+CSS3基础教程丨初学者从入门到精通 笔记参考 来自vectorX大佬的学习笔记 ","date":"2022-05-15","objectID":"/htmlcss/:4:0","tags":["前端","HTML","CSS"],"title":"HTML\u0026CSS","uri":"/htmlcss/"},{"categories":["前端"],"content":"前端学习计划","date":"2022-05-01","objectID":"/frontend/","tags":["前端","HTML","CSS","JS","Git","NodeJS","ES6","Ajax","axios","Promise","React","Webpack"],"title":"前端学习计划","uri":"/frontend/"},{"categories":["前端"],"content":"1 HTML、CSS（尚硅谷超哥） 视频链接：尚硅谷Web前端零基础入门HTML5+CSS3基础教程丨初学者从入门到精通 ","date":"2022-05-01","objectID":"/frontend/:0:1","tags":["前端","HTML","CSS","JS","Git","NodeJS","ES6","Ajax","axios","Promise","React","Webpack"],"title":"前端学习计划","uri":"/frontend/"},{"categories":["前端"],"content":"2 JavaScript（尚硅谷超哥） 视频链接：尚硅谷JavaScript基础\u0026实战丨JS入门到精通全套完整版 ","date":"2022-05-01","objectID":"/frontend/:0:2","tags":["前端","HTML","CSS","JS","Git","NodeJS","ES6","Ajax","axios","Promise","React","Webpack"],"title":"前端学习计划","uri":"/frontend/"},{"categories":["前端"],"content":"3 JavaScript进阶高级部分（尚硅谷）[可跳过] 视频链接：https://www.bilibili.com/video/BV14s411E7qf ⚠️注意：可以先不看这一块，直接看React，后面补js高级 ","date":"2022-05-01","objectID":"/frontend/:0:3","tags":["前端","HTML","CSS","JS","Git","NodeJS","ES6","Ajax","axios","Promise","React","Webpack"],"title":"前端学习计划","uri":"/frontend/"},{"categories":["前端"],"content":"4 React（尚硅谷天禹）[看P1-P64集] 视频链接：尚硅谷React技术全家桶全套完整版（零基础入门到精通/男神天禹老师亲授） ⚠️注意：P64集以后需要Ajax、Promis、axios等知识。 ","date":"2022-05-01","objectID":"/frontend/:0:4","tags":["前端","HTML","CSS","JS","Git","NodeJS","ES6","Ajax","axios","Promise","React","Webpack"],"title":"前端学习计划","uri":"/frontend/"},{"categories":["前端"],"content":"5 Ajax入门到精通（尚硅谷） 视频链接：https://www.bilibili.com/video/BV1WC4y1b78y ","date":"2022-05-01","objectID":"/frontend/:0:5","tags":["前端","HTML","CSS","JS","Git","NodeJS","ES6","Ajax","axios","Promise","React","Webpack"],"title":"前端学习计划","uri":"/frontend/"},{"categories":["前端"],"content":"6 Promise（尚硅谷） 视频链接：尚硅谷Web前端Promise教程从入门到精通 ","date":"2022-05-01","objectID":"/frontend/:0:6","tags":["前端","HTML","CSS","JS","Git","NodeJS","ES6","Ajax","axios","Promise","React","Webpack"],"title":"前端学习计划","uri":"/frontend/"},{"categories":["前端"],"content":"7 axios入门与源码解析（尚硅谷） 视频链接：尚硅谷Web前端axios入门与源码解析 ","date":"2022-05-01","objectID":"/frontend/:0:7","tags":["前端","HTML","CSS","JS","Git","NodeJS","ES6","Ajax","axios","Promise","React","Webpack"],"title":"前端学习计划","uri":"/frontend/"},{"categories":["前端"],"content":"8 React（尚硅谷天禹）[接着看P65-P141集] 视频链接：尚硅谷React技术全家桶全套完整版（零基础入门到精通/男神天禹老师亲授） ","date":"2022-05-01","objectID":"/frontend/:0:8","tags":["前端","HTML","CSS","JS","Git","NodeJS","ES6","Ajax","axios","Promise","React","Webpack"],"title":"前端学习计划","uri":"/frontend/"},{"categories":["前端"],"content":"9 ES6（尚硅谷） 视频链接：https://www.bilibili.com/video/BV1uK411H7on ⚠️注意：ES6需要先学习js基础、js高级、Promise等内容 ","date":"2022-05-01","objectID":"/frontend/:0:9","tags":["前端","HTML","CSS","JS","Git","NodeJS","ES6","Ajax","axios","Promise","React","Webpack"],"title":"前端学习计划","uri":"/frontend/"},{"categories":["前端"],"content":"10 NodeJS（尚硅谷） 视频链接：https://www.bilibili.com/video/BV1bs411E7pD ","date":"2022-05-01","objectID":"/frontend/:0:10","tags":["前端","HTML","CSS","JS","Git","NodeJS","ES6","Ajax","axios","Promise","React","Webpack"],"title":"前端学习计划","uri":"/frontend/"},{"categories":["前端"],"content":"11 Webpack（尚硅谷） 视频链接：https://www.bilibili.com/video/BV1e7411j7T5 ","date":"2022-05-01","objectID":"/frontend/:0:11","tags":["前端","HTML","CSS","JS","Git","NodeJS","ES6","Ajax","axios","Promise","React","Webpack"],"title":"前端学习计划","uri":"/frontend/"},{"categories":["前端"],"content":"12 Git（尚硅谷）[可以先会用再仔细看] 视频链接：https://www.bilibili.com/video/BV15J411973T ","date":"2022-05-01","objectID":"/frontend/:0:12","tags":["前端","HTML","CSS","JS","Git","NodeJS","ES6","Ajax","axios","Promise","React","Webpack"],"title":"前端学习计划","uri":"/frontend/"},{"categories":null,"content":"👋 𝑯𝒊 𝒕𝒉𝒆𝒓𝒆, 𝑾𝒆𝒍𝒄𝒐𝒎𝒆 𝒕𝒐 𝑴𝒚 𝑩𝒍𝒐𝒈! 𝑴𝒚 𝒏𝒂𝒎𝒆 𝒊𝒔 𝑴𝒊𝒍𝒐 🤝 𝑰 𝒂𝒎 𝒂 𝑾𝒆𝒃 𝑭𝒓𝒐𝒏𝒕-𝒆𝒏𝒅 𝑫𝒆𝒗𝒆𝒍𝒐𝒑𝒆𝒓 𝒇𝒓𝒐𝒎 𝑪𝒉𝒊𝒏𝒂 𝘼𝙗𝙤𝙪𝙩 𝙢𝙚 🏫 𝑺𝙝𝒂𝒏𝒈𝙝𝒂𝒊 𝑼𝒏𝒊𝒗𝒆𝒓𝒔𝒊𝒕𝒚 𝑶𝒇 𝑬𝒏𝒈𝒊𝒏𝒆𝒆𝒓𝒊𝒏𝒈 𝑺𝒄𝒊𝒆𝒏𝒄𝒆. 🏠 𝑩𝒂𝒔𝒆 𝑺𝙝𝒂𝒏𝒈𝙝𝒂𝒊, 𝒍𝒐𝒐𝒌𝒊𝒏𝒈 𝒇𝒐𝒓 𝒊𝒏𝒕𝒆𝒓𝒏𝒔𝒉𝒊𝒑 𝒐𝒑𝒑𝒐𝒓𝒕𝒖𝒏𝒊𝒕𝒊𝒆𝒔. 💼 𝑭𝒓𝒐𝒏𝒕𝑬𝒏𝒅 𝒆𝒏𝒕𝒉𝒖𝒔𝒊𝒂𝒔𝒕𝒔 𝒂𝒓𝒆 𝒌𝒆𝒆𝒏 𝒕𝒐 𝒘𝒓𝒊𝒕𝒆 𝒉𝒊𝒈𝒉-𝒒𝒖𝒂𝒍𝒊𝒕𝒚 𝒄𝒐𝒅𝒆. ❤️ 𝑰 𝒍𝒊𝒌𝒆 𝒕𝒐 𝒖𝒔𝒆 𝑻𝒚𝒑𝒆𝑺𝒄𝒓𝒊𝒑𝒕 𝒂𝒏𝒅 𝑹𝒆𝒂𝒄𝒕 𝒄𝒐𝒎𝒃𝒊𝒏𝒆𝒅 𝒘𝒊𝒕𝒉 𝑨𝒏𝒕 𝑫𝒆𝒔𝒊𝒈𝒏 𝒅𝒆𝒗𝒆𝒍𝒐𝒑𝒎𝒆𝒏𝒕 𝒑𝒓𝒐𝒋𝒆𝒄𝒕𝒔, 𝒂𝒏𝒅 𝒏𝒐𝒘 𝒔𝒐𝒎𝒆 𝒂𝒓𝒆 𝒆𝒙𝒑𝒍𝒐𝒓𝒊𝒏𝒈 𝒏𝒆𝒘 𝑼𝑰 𝒍𝒊𝒃𝒓𝒂𝒓𝒊𝒆𝒔. 💻 𝑪𝒐𝒅𝒊𝒏𝒈 𝒊𝒔 𝒎𝒚 𝒑𝒂𝒔𝒔𝒊𝒐𝒏. Milo ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"我 本科：上海工程技术大学 计算机科学与技术 硕士：上海工程技术大学 电子信息 研究方向-知识图谱、推荐系统 ","date":"0001-01-01","objectID":"/about/:0:1","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"Tags 爱打篮球、踢足球 喜欢吉他弹唱 前端开发 喜欢玩CSGO 不抽烟不喝酒不蹦迪 ","date":"0001-01-01","objectID":"/about/:0:2","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"技术评级 英语四六级 HTML\u0026CSS 入门 Less 了解 Javascript 入门 TS 了解 ES6 入门 NodeJs 入门 Wepack 入门 React 入门 Python 入门 Java 业余 Languages and Tools: ","date":"0001-01-01","objectID":"/about/:0:3","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"各位留个友链格式如下： name = Milo url = https://milo980412.github.io logo = https://milo980412.github.io/images/aniya.webp word = 保持谦逊，不断学习 Yulin Lewis \"不想当写手的码农不是好咸鱼_(xз」∠)_\" 李立超 \"前端我超哥!\" 小丞的前端日记 \"无比热爱，来日方长!\" zsqw123 \"岳女士 yyds\" 东南dnf \"周顺大弟子\" dextercai \"Helo.😄\" ","date":"0001-01-01","objectID":"/friends/:0:0","tags":null,"title":"友链墙","uri":"/friends/"},{"categories":null,"content":"感谢投喂～💗 支付宝 微信 ","date":"0001-01-01","objectID":"/donate/:0:1","tags":null,"title":"赞赏","uri":"/donate/"}]